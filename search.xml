<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基础数据结构与算法（一）</title>
      <link href="/2021/06/11/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2021/06/11/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本文章主要介绍线性结构的基本操作，代码来自浙大慕课。</p><span id="more"></span><h1 id="第一部分-线性结构"><a href="#第一部分-线性结构" class="headerlink" title="第一部分 线性结构"></a>第一部分 线性结构</h1><p><strong>线性结构主要包括线性表、堆栈和队列，基本操作有建立初始结构，插入、删除、判断是否为空或满的，不止线性结构如此，一般数据结构均是以上几种基本操作。</strong></p><h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><p>线性结构分为顺序存储和链表两种模式。</p><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>顺序存储即开辟一块固定空间，大小固定，所有操作均在这块空间上进行。</p><ul><li>开辟初始空间</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize Max</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> Cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">InitialList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L = (List)<span class="built_in">malloc</span>( <span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode) );</span><br><span class="line">    L-&gt;Cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断是否为空/为满</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">( List L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( L-&gt;Cnt == MaxSize )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">( List L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( L-&gt;Cnt == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">( List L, ElementType E )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">IsFull</span>( L ) )</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Full&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        L-&gt;Data[L-&gt;Cnt++] = E;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li>链表初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    List Next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">InitialList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//- 创建头结点的方法</span></span><br><span class="line">    List L = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">    L-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">( List L,ElementType Item )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List Temp = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">    Temp-&gt;Data = Item;</span><br><span class="line">    Temp-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;Next = Temp;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p>堆栈指满足先进后出原则的一个线性存储结构。</p><h3 id="顺序存储的堆栈"><a href="#顺序存储的堆栈" class="headerlink" title="顺序存储的堆栈"></a>顺序存储的堆栈</h3><ul><li>初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> Top;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack <span class="title">InitialStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack S = (Stack)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct SNode));</span><br><span class="line">    S-&gt;Top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断堆栈是否为满/为空</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">( Stack S )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( S-&gt;Top &lt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">( Stack S )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( S-&gt;Top == MaxSize<span class="number">-1</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">( Stack S,ElementType Item )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">IsFull</span>( S ) )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Full&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        S-&gt;Data[++S-&gt;Top] = Item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">Delete</span><span class="params">( Stack S )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">IsEmpty</span>( S ) )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;Data[S-&gt;Top--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆栈的链表存储结构（头结点结构）"><a href="#堆栈的链表存储结构（头结点结构）" class="headerlink" title="堆栈的链表存储结构（头结点结构）"></a>堆栈的链表存储结构（头结点结构）</h3><ul><li>初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    Stack Next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack <span class="title">InitialStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack S = (Stack)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>( struct SNode ));</span><br><span class="line">    S-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">( Stack S, ElementType Item )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack ItemP = (Stack)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct SNode));</span><br><span class="line">    ItemP-&gt;Data = Item;</span><br><span class="line">    ItemP-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    Stack Tmp;</span><br><span class="line">    Tmp = S-&gt;Next;</span><br><span class="line">    S-&gt;Next = ItemP;</span><br><span class="line">    ItemP-&gt;Next = Tmp;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">Delete</span><span class="params">( Stack S )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( S-&gt;Next == <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack Tmp = S-&gt;Next;</span><br><span class="line">    S-&gt;Next = Tmp-&gt;Next;</span><br><span class="line">    ElementType Item = Tmp-&gt;Data;</span><br><span class="line">    <span class="built_in">free</span>( Tmp );</span><br><span class="line">    <span class="keyword">return</span> Item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="顺序存储队列"><a href="#顺序存储队列" class="headerlink" title="顺序存储队列"></a>顺序存储队列</h3><ul><li>初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> Front;</span><br><span class="line">    <span class="keyword">int</span> Rear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//- 采用循环队列的方法，</span></span><br><span class="line"><span class="function">Queue <span class="title">InitialQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue Q = (Queue)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct QNode));</span><br><span class="line">    Q-&gt;Front = Q-&gt;Rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断为空/为满</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">( Queue Q )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Q-&gt;Front == Q-&gt;Rear )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">( Queue Q )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( (Q-&gt;Rear+<span class="number">1</span>)%MaxSize==Q-&gt;Front )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">( Queue Q, ElementType Item )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">IsFull</span>( Q ) )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Full&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Q-&gt;Rear = ( Q-&gt;Rear + <span class="number">1</span> )%MaxSize;</span><br><span class="line">        Q-&gt;Data[Q-&gt;Rear] = Item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Queue <span class="title">Delete</span><span class="params">( Queue Q )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType Item;</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">IsEmpty</span>( Q ) )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Q-&gt;Front = ( Q-&gt;Front + <span class="number">1</span> )%MaxSize;</span><br><span class="line">        Item = Q-&gt;Data[Q-&gt;Front];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表存储队列"><a href="#链表存储队列" class="headerlink" title="链表存储队列"></a>链表存储队列</h3><ul><li>初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    Queue Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeadQNode</span> *<span class="title">HeadQueue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeadQNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Queue Front;</span><br><span class="line">    Queue Rear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">HeadQueue <span class="title">Initial</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HeadQueue HQ = (HeadQueue)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct HeadQNode));</span><br><span class="line">    HQ-&gt;Front = HQ-&gt;Rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> HQ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">( HeadQueue HQ, ElementType Item )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue Q = (Queue)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct QNode));</span><br><span class="line">    Q-&gt;Data = Item;</span><br><span class="line">    Q-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>( HQ-&gt;Front == <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        HQ-&gt;Front = Q;</span><br><span class="line">        HQ-&gt;Rear = Q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Queue RearQ = HQ-&gt;Rear;</span><br><span class="line">        RearQ-&gt;Next = Q;</span><br><span class="line">        HQ-&gt;Rear = Q;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">Delete</span><span class="params">( HeadQueue HQ )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( HQ-&gt;Front == <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( HQ-&gt;Front == HQ-&gt;Rear )</span><br><span class="line">    &#123;</span><br><span class="line">        ElementType Item = HQ-&gt;Front-&gt;Data;</span><br><span class="line">        <span class="built_in">free</span>( HQ-&gt;Front );</span><br><span class="line">        HQ-&gt;Front = HQ-&gt;Rear = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> Item;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue Q = HQ-&gt;Front;</span><br><span class="line">    HQ-&gt;Front = Q-&gt;Next;</span><br><span class="line">    ElementType Item = Q-&gt;Data;</span><br><span class="line">    <span class="built_in">free</span>(Q);</span><br><span class="line">    <span class="keyword">return</span> Item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown使用手册</title>
      <link href="/2021/06/06/MarkDown%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
      <url>/2021/06/06/MarkDown%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p>为MarkDown的使用提供一份说明文档，部分结果仅展示成果，可以复制到本地的<a href="https://www.typora.io/">Typora</a>查看源码。未来会持续更新</p><span id="more"></span><h3 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h3><p>标题一共包括六个级别，用#来表示，示意如下：<br># 标题1<br>## 标题2<br>### 标题3<br>#### 标题4<br>##### 标题5<br>###### 标题6<br>在MarkDown下分别表示如下：</p><h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><h2 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h2><h3 id="标题3"><a href="#标题3" class="headerlink" title="标题3"></a>标题3</h3><h4 id="标题4"><a href="#标题4" class="headerlink" title="标题4"></a>标题4</h4><h5 id="标题5"><a href="#标题5" class="headerlink" title="标题5"></a>标题5</h5><h6 id="标题6"><a href="#标题6" class="headerlink" title="标题6"></a>标题6</h6><p><strong>注：# 和字符中间空一格</strong></p><h3 id="二、列表"><a href="#二、列表" class="headerlink" title="二、列表"></a>二、列表</h3><p>列表的使用时-空一格加字符，如下：<br>- 文本1<br>- 文本2<br>- 文本3</p><ul><li>文本1</li><li>文本2</li><li>文本3</li></ul><p>如果加上有序序号的话</p><ol><li>文本1</li><li>文本2</li><li>文本3</li></ol><h3 id="三、插入链接和图片"><a href="#三、插入链接和图片" class="headerlink" title="三、插入链接和图片"></a>三、插入链接和图片</h3><h4 id="1-插入链接"><a href="#1-插入链接" class="headerlink" title="1.插入链接"></a>1.插入链接</h4><p>插入链接使用[显示文本]+(网址)的方式来显示链接，具体如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[百度](https://www.baidu.com/)</span><br></pre></td></tr></table></figure><p><a href="https://www.baidu.com/">百度</a></p><h4 id="2-插入图片"><a href="#2-插入图片" class="headerlink" title="2.插入图片"></a>2.插入图片</h4><p>出入图片和插入链接相似，使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://gitee.com/nighost/case/raw/master/Case.png)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/nighost/case/raw/master/Case.png" alt=""></p><p><strong>注：印象笔记的网址解析有问题，所以这里没有显示，但大体是这样用</strong></p><h3 id="四、引用"><a href="#四、引用" class="headerlink" title="四、引用"></a>四、引用</h3><p>引用只要使用> 文字即可</p><blockquote><p>人生得意须尽欢，莫使金樽空对月</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 人生得意须尽欢，莫使金樽空对月</span><br></pre></td></tr></table></figure><h3 id="五、粗体和斜体"><a href="#五、粗体和斜体" class="headerlink" title="五、粗体和斜体"></a>五、粗体和斜体</h3><p>斜体使用两个*，粗体使用四个*<br><em>斜体</em><br><strong>粗体</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*斜体*</span><br><span class="line">**粗体**</span><br></pre></td></tr></table></figure><h3 id="六、代码引用"><a href="#六、代码引用" class="headerlink" title="六、代码引用"></a>六、代码引用</h3><h4 id="1-单行代码"><a href="#1-单行代码" class="headerlink" title="1.单行代码"></a>1.单行代码</h4><p><code>hello world</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`hello world`</span><br></pre></td></tr></table></figure><h4 id="2-代码块"><a href="#2-代码块" class="headerlink" title="2.代码块"></a>2.代码块</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;isotream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、表格"><a href="#七、表格" class="headerlink" title="七、表格"></a>七、表格</h3><div class="table-container"><table><thead><tr><th>辛烷值</th><th>正庚烷比例</th><th>异辛烷比例</th><th>甲苯比例</th></tr></thead><tbody><tr><td>100</td><td>0</td><td>100</td><td>0</td></tr><tr><td>70</td><td>30</td><td>70</td><td>0</td></tr></tbody></table></div><h3 id="八、数学公式"><a href="#八、数学公式" class="headerlink" title="八、数学公式"></a>八、数学公式</h3><h4 id="1-行内公式和读行公式"><a href="#1-行内公式和读行公式" class="headerlink" title="1.行内公式和读行公式"></a>1.行内公式和读行公式</h4><ul><li>行内公式<br>一些内容$1+1=2$</li><li>独行公式<script type="math/tex; mode=display">1+1=2</script></li></ul><h4 id="2-上标、下标与组合"><a href="#2-上标、下标与组合" class="headerlink" title="2.上标、下标与组合"></a>2.上标、下标与组合</h4><ul><li><p>上标</p><script type="math/tex; mode=display">2^2=4</script></li><li><p>下标</p><script type="math/tex; mode=display">U_k=5</script></li><li><p>组合<br>使用{}来包含，避免歧义</p><script type="math/tex; mode=display">{16}_{8}O{2+}_{2}</script></li></ul><h4 id="3-汉字、字体与格式"><a href="#3-汉字、字体与格式" class="headerlink" title="3.汉字、字体与格式"></a>3.汉字、字体与格式</h4><ul><li>汉字<br>汉字的输入格式如下：<br>\$$V_{\mbox{初始}}$$<br><strong>注：印象笔记不支持数学公式中的汉字输入</strong></li><li>字体控制<br>不知道怎么做的控制，但加入displaystyle后字体明显变好看，如下：<br>$\displaystyle \frac{x+y}{y+z}$<br>$\frac{x+y}{y+z}$<br>再比如加和符号：<br>$\displaystyle \sum_X$<br>$\sum_X$<br>可以看到，加入字体控制，X的布局更合理</li><li>下划线控制<br>${x+y}$<br>$\underline {x+y}$</li><li>标签<br>$\tag{11}$<br><strong>注：印象笔记也不支持这个功能</strong></li><li>上大括号<br>$\overbrace{a+b+c+d}$</li><li>下大括号<br>$\underbrace {a+b+c+d}$</li><li><p>上位符号<br>写法如下<br>$stakcrel{上位符号}{基位符号}$<br>$\vec{x}\stackrel{\mathrm{def}}{=}{x_1,\dots,x_n}$<br>$\stackrel{\mathrm{de}}{=}$</p></li><li><p>公式字符加粗</p></li><li>$\boldsymbol{S}$</li></ul><h4 id="4-占位符"><a href="#4-占位符" class="headerlink" title="4.占位符"></a>4.占位符</h4><ul><li>两个quad空格<br>$x\qquad y$</li><li>一个quad空格<br>$x\quad y$</li><li>大空格(\加一个空格)<br>$x\ y$</li><li>中空格<br>$x\:y$</li><li>小空格<br>$x\,y$</li><li>没有空格<br>$xy$</li><li>紧贴<br>$x!y$</li></ul><h4 id="5-定位符与组合"><a href="#5-定位符与组合" class="headerlink" title="5.定位符与组合"></a>5.定位符与组合</h4><ul><li>括号<br>$(xy)$</li><li>中括号<br>$[xy]$</li><li>大括号<br>$\{xy\}$</li></ul><h4 id="6-四则运算"><a href="#6-四则运算" class="headerlink" title="6.四则运算"></a>6.四则运算</h4><ul><li>加法<br>$x+y=z$</li><li>减法<br>$x-y=z$</li><li>加减法<br>$x \pm y = z$</li><li>减加法<br>$x \mp y = z$</li><li>乘法<br>$x \times y = z$</li><li>点乘<br>$x \cdot y = z$</li><li>星乘<br>$x \ast y = z$</li><li>除法<br>$x \div y = z$</li><li>斜法<br>$x / y = z$</li><li>分式表示<br>$\displaystyle \frac{x}{y}$</li><li>分式表示<br>${x} \voer {y}$<br><strong>注：印象笔记不支持该显示</strong></li><li>绝对值<br>$|x|=|y|$</li></ul><h4 id="7-高级运算"><a href="#7-高级运算" class="headerlink" title="7.高级运算"></a>7.高级运算</h4><ul><li>平均数计算<br>$\displaystyle \overline{xyz}$</li><li>开二次方<br>$\sqrt x$</li><li>开方运算<br>$\sqrt[3]{xy}$</li><li>对数运算<br>$\log(x)$</li><li>极限运算<br>$\lim^{x\to\infty}_{y\to0}{\frac{x}{y}}$</li><li>字符控制极限运算<br>$\displaystyle \lim^{x\to\infty}_{y\to0}{\frac{x}{y}}$</li><li>求和运算<br>$\sum^{x\to\infty}_{y\to0}{\frac{x}{y}}$</li><li>字符控制求和运算<br>$\displaystyle \sum^{x\to\infty}_{y\to0}{\frac{x}{y}}$</li><li>积分运算<br>$\int^{\infty}_{0}xdx$</li><li>字符控制积分运算<br>$\displaystyle \int^{\infty}_{0}xdx$</li><li>微分运算<br>$\frac{\partial x}{\partial y}$</li><li>字符控制微分运算<br>$\displaystyle \frac{\partial x}{\partial y}$</li><li>矩阵表示<br>中括号表示</li></ul><script type="math/tex; mode=display">\left[\begin{matrix}   1 & 2 & 3\\   4 & 5 & 6\\   7 & 8 & 9\end{matrix}\right]</script><p>大括号表示</p><script type="math/tex; mode=display">\left\{\begin{matrix}   1 & 2 & 3\\   4 & 5 & 6\\   7 & 8 & 9'\end{matrix}\right\}</script><h5 id="8-逻辑运算"><a href="#8-逻辑运算" class="headerlink" title="8.逻辑运算"></a>8.逻辑运算</h5><ul><li>等于<br>$x+y=z$</li><li>大于<br>$x+y&gt;z$</li><li>小于<br>$x+y&lt;z$</li><li>大于等于<br>$x+y \geq z$</li><li>小于等于<br>$x+y \leq z$</li><li>不等于<br>$x+y \neq z$</li><li>不大于等于<br>$x+y \ngeq z$</li><li>不大于等于<br>$x+y \not\geq z$</li><li>不小于等于<br>$x+y \nleq z$</li><li>不小于等于<br>$x+y \not\leq z$</li><li>约等于<br>$x+y \approx z$</li><li>恒定等于<br>$x+y \equiv z$</li></ul><h5 id="9-集合运算"><a href="#9-集合运算" class="headerlink" title="9.集合运算"></a>9.集合运算</h5><ul><li>属于<br>$x \in y$</li><li>不属于<br>$x \notin y$</li><li>不属于<br>$x \not\in y$</li><li>子集<br>$x \subset y$<br>$x \supset y$</li><li>真子集<br>$x \subseteq y$<br>$x \supseteq y$</li><li>非真子集<br>$x \subsetneq y$<br>$x \supsetneq y$</li><li>非子集<br>$x \not\subset y$<br>$x \not\supset y$</li><li>并集<br>$x \cup y$</li><li>交集<br>$x \cap y$</li><li>差集<br>$x \setminus y$</li><li>同或<br>$x \bigodot y$</li><li>同与<br>$x \bigotimes y$</li><li>实数<br>$\mathbb{R}$</li><li>自然数<br>$\mathbb{Z}$</li><li>空集<br>$\emptyset$</li></ul><h5 id="10-数学符号"><a href="#10-数学符号" class="headerlink" title="10.数学符号"></a>10.数学符号</h5><ul><li><p>无穷<br>$\infty$</p></li><li><p>虚数<br>$\imath$<br>$\jmath$</p></li><li><p>数学符号<br>$\displaystyle \hat{a}$<br>$\check{a}$<br>$\breve{a}$<br>$\tilde{a}$<br>$\bar{a}$<br>$\acute{a}$<br>$\grave{a}$<br>$\mathring{a}$</p></li><li><p>矢量符号<br>$\displaystyle \vec{a}$</p></li><li><p>一阶导数符号<br>$\dot{a}$</p></li><li><p>二阶导数符号<br>$\ddot{a}$</p></li><li><p>上箭头<br>$\uparrow$<br>$\Uparrow$</p></li><li><p>下箭头<br>$\downarrow$<br>$\Downarrow$</p></li><li><p>左箭头<br>$\leftarrow$<br>$\Leftarrow$</p></li><li><p>右箭头<br>$\rightarrow$<br>$\Rightarrow$</p></li><li><p>低端对齐省略号<br>$1,2,\ldots,n$</p></li><li><p>中线对齐省略号<br>$\displaystyle X_1^2+X_2^2+X_3^2+\cdots+X_N^2$</p></li><li><p>竖直对齐省略号(矩阵使用)<br>$\vdots$</p></li><li><p>斜对齐省略号<br>$\ddots$</p></li><li><p>散度/梯度符号<br>$\nabla$</p></li><li><p>向下取整</p><p>$\lfloor$</p><p>$\rfloor$</p></li><li><p>向上取整</p><p>$\lceil$</p><p>$\rceil$</p></li></ul><h5 id="11-希腊字母"><a href="#11-希腊字母" class="headerlink" title="11.希腊字母"></a>11.希腊字母</h5><div class="table-container"><table><thead><tr><th>字母</th><th>实现</th><th>字母</th><th>实现</th></tr></thead><tbody><tr><td>A</td><td>A</td><td>$\alpha$</td><td>\alpha</td></tr><tr><td>B</td><td>B</td><td>$\beta$</td><td>\beta</td></tr><tr><td>$\Gamma$</td><td>\Gamma</td><td>$\gamma$</td><td>\gamma</td></tr><tr><td>$\Delta$</td><td>\Delta</td><td>$\delta$</td><td>\delta</td></tr><tr><td>E</td><td>E</td><td>$\epsilon$</td><td>\epsilon</td></tr><tr><td>Z</td><td>Z</td><td>$\zeta$</td><td>\zeta</td></tr><tr><td>H</td><td>H</td><td>$\eta$</td><td>\eta</td></tr><tr><td>$\Theta$</td><td>\Theta</td><td>$\theta$</td><td>\theta</td></tr><tr><td>I</td><td>I</td><td>$\iota$</td><td>\iota</td></tr><tr><td>K</td><td>K</td><td>$\kappa$</td><td>\kappa</td></tr><tr><td>$\Lambda$</td><td>\Lambda</td><td>$\lambda$</td><td>\lambda</td></tr><tr><td>M</td><td>M</td><td>$\mu$</td><td>\mu</td></tr><tr><td>N</td><td>N</td><td>$\nu$</td><td>\nu</td></tr><tr><td>$\Xi$</td><td>\Xi</td><td>$\xi$</td><td>\xi</td></tr><tr><td>O</td><td>$O$</td><td>$\omicron$</td><td>\omicron</td></tr><tr><td>$\Pi$</td><td>\Pi</td><td>$\pi$</td><td>\pi</td></tr><tr><td>$P$</td><td>P</td><td>$\rho$</td><td>\rho</td></tr><tr><td>$\Sigma$</td><td>\Sigma</td><td>$\sigma$</td><td>\sigma</td></tr><tr><td>T</td><td>T</td><td>$\tau$</td><td>\tau</td></tr><tr><td>$\Upsilon$</td><td>\Upsilon</td><td>$\upsilon$</td><td>\upsilon</td></tr><tr><td>$\Phi$</td><td>\Phi</td><td>$\phi$</td><td>\phi</td></tr><tr><td>$X$</td><td>X</td><td>$\chi$</td><td>\chi</td></tr><tr><td>$\Psi$</td><td>\Psi</td><td>$\psi$</td><td>\psi</td></tr><tr><td>$\Omega$</td><td>\Omega</td><td>$\omega$</td><td>\omega</td></tr></tbody></table></div><h5 id="12-多行数学公式"><a href="#12-多行数学公式" class="headerlink" title="12.多行数学公式"></a>12.多行数学公式</h5><script type="math/tex; mode=display">\begin{aligned}x &= v_0\cos\theta t \\y &= v_0\sin\theta t - \frac{1}{2}gt^2 \\y &= v_0\sin\theta t - \frac{1}{2}gt^2\end{aligned}</script><h3 id="九、流程图"><a href="#九、流程图" class="headerlink" title="九、流程图"></a>九、流程图</h3><p><strong>注：在印象笔记中流程图使用代码块功能，但在其他markdown中不用使用代码块</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[模块A] --&gt;|A1| B(模块B)</span><br><span class="line">B --&gt; C&#123;判断条件C&#125;</span><br><span class="line">C --&gt;|条件C1| D[模块D]</span><br><span class="line">C --&gt;|条件C2| E[模块E]</span><br><span class="line">C --&gt;|条件C3| F[模块F]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
