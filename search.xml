<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>并行计算入门</title>
      <link href="/2021/07/12/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E5%85%A5%E9%97%A8/"/>
      <url>/2021/07/12/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<p>本文章主要介绍如何在服务器上部署MPI，基本的并行计算算法以及如何利用MPI实现矩阵的加法和乘法。</p><span id="more"></span><h1 id="服务器部署MPI"><a href="#服务器部署MPI" class="headerlink" title="服务器部署MPI"></a>服务器部署MPI</h1><p> 一般用于大型科学计算的服务器为作业调度系统，这里以PBS系统为例。</p><p>首先，找到用户下的<strong>.bashrc</strong>文件，初始内容如下。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># .bashrc</span><br><span class="line"></span><br><span class="line"># Source global definitions</span><br><span class="line">if [ -f /etc/bashrc ]; then</span><br><span class="line">        . /etc/bashrc</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line"># Uncomment the following line if you don&#x27;t like systemctl&#x27;s auto-paging feature;</span><br><span class="line"># export SYSTEMD_PAGER=</span><br><span class="line"></span><br><span class="line"># User specific aliases and functions</span><br><span class="line">module load mpi</span><br></pre></td></tr></table></figure><p>可以看到默认环境部署是包含了MPI环境的，为了更好的使用指定的MPI环境，可以采用<strong>unload</strong>和<strong>load</strong>的方法，本文采用mpich来进行并行计算。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># User specific aliases and functions</span><br><span class="line"># module load mpi</span><br><span class="line">module unload mpi/openmpi-x86_64</span><br><span class="line">module load mpi/mpich-3.2-x86_64</span><br></pre></td></tr></table></figure><p>至此，服务器上的并行环境部署完毕，对于其他Linux系统，环境部署操作相似。</p><h1 id="并行计算样例（C-）"><a href="#并行计算样例（C-）" class="headerlink" title="并行计算样例（C++）"></a>并行计算样例（C++）</h1><p>看如下一个简单的并行计算的样例<strong>hellof90.cpp</strong>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mpi.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> MyId,NumProcs;</span><br><span class="line">    <span class="built_in">MPI_Init</span>( &amp;argc,&amp;argv );</span><br><span class="line">    <span class="built_in">MPI_Comm_rank</span>( MPI_COMM_WORLD, &amp;MyId );</span><br><span class="line">    <span class="built_in">MPI_Comm_size</span>( MPI_COMM_WORLD, &amp;NumProcs );</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;Hello World! My id is %d.\n&quot;</span>,MyId );</span><br><span class="line">    <span class="built_in">MPI_Finalize</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>采用以下命令将上述cpp文件编译、链接成可执行程序</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpicxx -o hellof90 hellof90.cpp</span><br></pre></td></tr></table></figure><p>封装的程序可以执行并行计算和串行计算。串行计算指令和结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./hellof90</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello World! my id is:0.</span><br></pre></td></tr></table></figure><p>采用四个核做并行计算，执行指令和并行计算结果如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mpirun -np 4 ./hellof90</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Hello World! my id is:1</span><br><span class="line">Hello World! my id is:2</span><br><span class="line">Hello World! my id is:3</span><br><span class="line">Hello World! my id is:0</span><br></pre></td></tr></table></figure><p>从以上计算结果，我们可以简单地认为并行计算就是将一份代码分给若干个不同的核去做计算。</p><h1 id="基本的MPI函数"><a href="#基本的MPI函数" class="headerlink" title="基本的MPI函数"></a>基本的MPI函数</h1><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">MPI_Init( &amp;argc,&amp;argv ); //- 开始进行并行计算</span><br><span class="line">MPI_Comm_rank( MPI_COMM_WORLD, &amp;MyId ); //- 给出当前并行计算的核编号</span><br><span class="line">MPI_Comm_size( MPI_COMM_WORLD, &amp;NumProcs ); //- 给出用于并行计算的总核数</span><br><span class="line">MPI_Finalize(); //- 常做为结束并行计算的标志</span><br><span class="line">MPI_Send( 要发送的对象地址,发送的数量,数据类型,标识符,发送的位置,MPI_COMM_WORLD );</span><br><span class="line">MPI_Recv( 要接收的对象地址,接收的数量,数据类型,标识符,接收的位置,MPI_COMM_WORLD,&amp;status );</span><br><span class="line">MPI_Sendrecv( 要发送的对象地址,发送的数量,数据类型,标识符,发送的位置,</span><br><span class="line">              要接收的对象地址，接收的数量，数据类型,标识符,接收的位置,MPI_COMM_WORLD,&amp;status );</span><br><span class="line">MPI_Barrier( MPI_COMM_WORLD ); //- 同步</span><br><span class="line">MPI_Reduce( 发送缓冲区,接收缓冲区,数目,数据类型,规约操作,通讯域 ); //- 规约（求和、求最大值，求最小值...）</span><br><span class="line">//- 预定义的规约操作</span><br><span class="line">MPI_MAX    最大值</span><br><span class="line">MPI_MIN    最小值</span><br><span class="line">MPI_SUM    求和</span><br><span class="line">MPI_PROD   求积</span><br><span class="line">MPI_LAND   逻辑与</span><br><span class="line">MPI_BAKD   按位与</span><br><span class="line">MPI_LOR    逻辑或</span><br><span class="line">MPI_BOR    按位或</span><br><span class="line">MPI_LXOR   逻辑异或</span><br><span class="line">MPI_BXOR   按位异或</span><br><span class="line">MPI_MAXLOC 最大值及位置</span><br><span class="line">MPI_MINLOC 最小值及位置</span><br><span class="line"></span><br><span class="line">MPI_Bcast( 数据缓冲区,数目,数据类型,根进程,通讯域 ); //- 广播，采用树状传播的方式将信息传送到所有进程中</span><br><span class="line">MPI_Wtime(); //- 打印系统时间函数</span><br></pre></td></tr></table></figure><h1 id="锁死"><a href="#锁死" class="headerlink" title="锁死"></a>锁死</h1><p>在并行计算的发送和接收中可能会出现锁死的现象，原因是MPI做发送动作时需要确定对方完成接收动作，A核的发动动作才能返回，继续做下一步操作；接收动作同理，因此当A核向B核做发送动作，B核向A核做发送动作就一定会造成锁死。为了避免锁死出现，最好使用MPI_Sendrecv()函数做发送和接收。</p><h1 id="循环队列和对等式编程思想"><a href="#循环队列和对等式编程思想" class="headerlink" title="循环队列和对等式编程思想"></a>循环队列和对等式编程思想</h1><p>与对等式编程思想相对的是顺序式编程思想，顺序式编程思想是指存在一个<strong>主核</strong>，主核在进行一些操作时，会收集其他核的信息，并将重要的操作应用到主核上，从而造成负载不平衡。</p><p>通俗来说，不对进程搞“特殊对待”即是对等式编程思想。</p><h1 id="并行计算初步应用——矩阵乘法"><a href="#并行计算初步应用——矩阵乘法" class="headerlink" title="并行计算初步应用——矩阵乘法"></a>并行计算初步应用——矩阵乘法</h1><p>矩阵<script type="math/tex">A，B</script>均为<script type="math/tex">N*N</script>的方阵，计算矩阵<script type="math/tex">C=AB</script>；使用P个进程并行计算（N可以被P整除）；矩阵A，B及C均采用分布式存储；A,C按行分割，B按列分割存储。</p><p>矩阵A，B采用如下值，N设为2000</p><script type="math/tex; mode=display">\LargeA_{i,j}=e^{y_j}cos(x_i);B_{ij}=(x_i+cos(4x_i))(1+y_j);x_i=(i-1)/(N-1);y_j=(j-1)/(N-1)</script><p>计算出C矩阵后，请计算$S=\frac{1}{N^2}\Sigma^{N}_{j=1}\Sigma^{N}_{i=1}c^2_{ij}$，并由根结点打印出来。</p><p>将S值与串行程序的结果进行对比，检验程序的正确性；</p><p>使用1,2,4,10个进程进行计算，并利用MPI_Wtime()函数计算程序运行时间；考核加速比及计算效率。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;mpi.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cmath&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;math.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MatrixSize 2000</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">( <span class="keyword">int</span> argc,<span class="keyword">char</span> *argv[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//double A[MatrixSize][MatrixSize],B[MatrixSize][MatrixSize],C[MatrixSize][MatrixSize];</span></span><br><span class="line">    <span class="keyword">int</span> myid,nProcs;</span><br><span class="line">    <span class="keyword">int</span> NP;</span><br><span class="line">    <span class="keyword">double</span> Xi,Yj,time_begin,time_end;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;</span><br><span class="line">    <span class="built_in">MPI_Init</span>( &amp;argc,&amp;argv );</span><br><span class="line">    time_begin = <span class="built_in">MPI_Wtime</span>();</span><br><span class="line">    <span class="built_in">MPI_Comm_rank</span>( MPI_COMM_WORLD,&amp;myid );</span><br><span class="line">    <span class="built_in">MPI_Comm_size</span>( MPI_COMM_WORLD,&amp;nProcs );</span><br><span class="line">    NP = MatrixSize/nProcs;</span><br><span class="line">    <span class="keyword">double</span> A1[NP][MatrixSize],B1[MatrixSize][NP],C1[NP][MatrixSize];</span><br><span class="line">    <span class="keyword">double</span> Btmp[MatrixSize][NP],Ctmp,S,Stmp,Stotal;</span><br><span class="line">    <span class="keyword">int</span> id_send,id_recv,step;</span><br><span class="line">    MPI_Status status;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;NP;i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        Ctmp = <span class="number">0</span>;</span><br><span class="line">        Xi = (myid*NP+i)/(MatrixSize<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">for</span>( j=<span class="number">0</span>;j&lt;MatrixSize;j++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//Xi = (myid*NP+i)/(MatrixSize-1);</span></span><br><span class="line">            Yj = j/(MatrixSize<span class="number">-1</span>);</span><br><span class="line">            A1[i][j] = <span class="built_in">exp</span>(Yj) * <span class="built_in">cos</span>(Xi);</span><br><span class="line">            B1[j][i] = (Yj + <span class="built_in">cos</span>(<span class="number">4</span>*Yj)) * (<span class="number">1</span> + Xi);</span><br><span class="line">            <span class="comment">//printf( &quot;%lf\n&quot;,A[i][j] );</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;NP;i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>( k=<span class="number">0</span>;k&lt;NP;k++ )</span><br><span class="line">        &#123;</span><br><span class="line">            Ctmp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>( j=<span class="number">0</span>;j&lt;MatrixSize;j++ )</span><br><span class="line">            &#123;</span><br><span class="line">                Ctmp += A1[i][j] * B1[j][k];</span><br><span class="line">            &#125;</span><br><span class="line">            C1[i][myid*NP+k] = Ctmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>( step=<span class="number">1</span>;step&lt;nProcs;step++ )</span><br><span class="line">    &#123;</span><br><span class="line">        id_send = (myid+nProcs+step)%nProcs;</span><br><span class="line">        id_recv = (myid+nProcs-step)%nProcs;</span><br><span class="line">        <span class="built_in">MPI_Sendrecv</span>( B1,MatrixSize*NP,MPI_DOUBLE,id_send,<span class="number">99</span>,</span><br><span class="line">                      Btmp,MatrixSize*NP,MPI_DOUBLE,id_recv,<span class="number">99</span>,MPI_COMM_WORLD,&amp;status );</span><br><span class="line">        <span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;NP;i++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>( k=<span class="number">0</span>;k&lt;NP;k++ )</span><br><span class="line">            &#123;</span><br><span class="line">                Ctmp = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">for</span>( j=<span class="number">0</span>;j&lt;MatrixSize;j++ )</span><br><span class="line">                &#123;</span><br><span class="line">                    Ctmp += A1[i][j] * Btmp[j][k];</span><br><span class="line">                &#125;</span><br><span class="line">                C1[i][id_recv*NP+k] = Ctmp;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    S = <span class="number">0</span>;</span><br><span class="line">    Stotal = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>;i&lt;NP;i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>( j=<span class="number">0</span>;j&lt;MatrixSize;j++ )</span><br><span class="line">        &#123;</span><br><span class="line">            S += C1[i][j] * C1[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    S /= (MatrixSize*MatrixSize);</span><br><span class="line">    Stotal += S;</span><br><span class="line">    <span class="keyword">for</span>( step=<span class="number">1</span>;step&lt;nProcs;step++ )</span><br><span class="line">    &#123;</span><br><span class="line">        id_send = (myid+nProcs+step)%nProcs;</span><br><span class="line">        id_recv = (myid+nProcs-step)%nProcs;</span><br><span class="line">        <span class="built_in">MPI_Sendrecv</span>( &amp;S,<span class="number">1</span>,MPI_DOUBLE,id_send,<span class="number">99</span>,</span><br><span class="line">                      &amp;Stmp,<span class="number">1</span>,MPI_DOUBLE,id_recv,<span class="number">99</span>,MPI_COMM_WORLD,&amp;status );</span><br><span class="line">        Stotal += Stmp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>( <span class="string">&quot;S in processor%d is %lf\n&quot;</span>,myid,Stotal );</span><br><span class="line">    time_end = <span class="built_in">MPI_Wtime</span>();</span><br><span class="line">    <span class="keyword">if</span>( myid == <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>( <span class="string">&quot;Total Time of NP%d is %lf.\n&quot;</span>,nProcs,time_end-time_begin );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">MPI_Finalize</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>先验证串行计算的正确性，将MatrixSize定义为3，得到以下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">//- 矩阵A</span><br><span class="line">1.000000 1.000000 2.718282</span><br><span class="line">1.000000 1.000000 2.718282</span><br><span class="line">0.540302 0.540302 1.468694</span><br><span class="line"></span><br><span class="line">//- 矩阵B</span><br><span class="line">1.000000 1.000000 2.000000</span><br><span class="line">1.000000 1.000000 2.000000</span><br><span class="line">0.346356 0.346356 0.692713</span><br><span class="line"></span><br><span class="line">//- S</span><br><span class="line">13.22042</span><br></pre></td></tr></table></figure><p>按照矩阵乘法规则可以验证计算结果是正确的。</p><p>采用并行计算，用3个核做计算，计算结果如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">S in processor0 is 13.220426</span><br><span class="line">S in processor1 is 13.220426</span><br><span class="line">S in processor2 is 13.220426</span><br></pre></td></tr></table></figure><p>并行计算结果与串行结果相同。</p><p>将方阵规模设置成2000，重做计算，得到如下计算速度和加速比。</p><p><img src="https://gitee.com/nighost/image-base-of-blog/raw/master/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E5%85%A5%E9%97%A8/%E5%B9%B6%E8%A1%8C%E8%AE%A1%E7%AE%97%E5%85%A5%E9%97%A8%E2%80%94%E2%80%94%E7%9F%A9%E9%98%B5%E4%B9%98%E6%B3%95%E2%80%94%E2%80%94%E8%AE%A1%E7%AE%97%E6%95%88%E7%8E%87%E5%92%8C%E5%8A%A0%E9%80%9F%E6%AF%94.png" alt=""></p><center>    图1 计算速度和加速比</center><p>可以发现并行计算可以按使用的核数做到线性的加速效果。</p>]]></content>
      
      
      <categories>
          
          <category> 计算流体力学自研 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>王道计算机组成原理（一）</title>
      <link href="/2021/06/28/%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2021/06/28/%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>王道计算机组成原理第一章。</p><span id="more"></span><h1 id="1-计算机系统层次结构"><a href="#1-计算机系统层次结构" class="headerlink" title="1 计算机系统层次结构"></a>1 计算机系统层次结构</h1><h2 id="1-1-早期冯诺依曼机"><a href="#1-1-早期冯诺依曼机" class="headerlink" title="1.1 早期冯诺依曼机"></a>1.1 早期冯诺依曼机</h2><p><strong>“存储程序”</strong>：将指令以二进制代码的形式事先输入计算机的主存储器，然后按其在存储器中的首地址执行程序的第一条指令，以后就按该程序的规定顺序执行其他指令，直至程序执行结束。其特点如下：</p><ol><li>计算机硬件系统由运算器、存储器、控制器、输入设备和输出设备五大部件组成</li><li>指令和数据以同等地位存储在存储器中，并可按地址寻访。</li><li>指令和数据均用二进制代码表示。</li><li>指令由操作码和地址码组成，操作码用来表示操作的性质，地址码用来表示操作数在存储器中的位置。</li><li>指令在存储器内按顺序存放。通常指令是顺序执行的，在特定条件下可根据运算结果或根据设定的条件改变执行顺序。</li><li>早期冯诺依曼机以运算器为中心，输入/输出设备通过运算器与存储器传送数据。</li></ol><p><img src="https://gitee.com/nighost/image-base-of-blog/raw/master/%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%8E%8B%E9%81%93%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%BE1_1.png" alt=""></p><center>图1-1 典型冯诺依曼机结构</center><p>存储器：存放数据和程序</p><p>运算器：算术运算和逻辑运算</p><p>控制器：通过存储器传输数据到控制器，来解析指令并指挥程序运行</p><ul><li>在计算机系统中，即可以通过硬件也可以通过软件实现以上的计算机体系结构。</li></ul><h2 id="1-2-现代计算机结构"><a href="#1-2-现代计算机结构" class="headerlink" title="1.2 现代计算机结构"></a>1.2 现代计算机结构</h2><p>冯诺依曼机是以运算器为中心，但很多数据并不需要做运算，因此造成步骤冗余，以此现代计算机结构采用存储器为中心的方式。</p><p><img src="https://gitee.com/nighost/image-base-of-blog/raw/master/%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%8E%8B%E9%81%93%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%BE1_2.png" alt=""></p><center>    图1-2 现代计算机系统结构</center><p>整合运算器和控制器的现代处理单元即CPU，集成后的体系结构如下：</p><p><img src="https://gitee.com/nighost/image-base-of-blog/raw/master/%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%8E%8B%E9%81%93%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%BE1_3.png" alt=""></p><center>    图1-3 集成CPU后的计算机体系结构图</center><p>控制器通过控制线给运算器发送接下来应该进行的运算操作，并通过控制线控制外设；主存储器通过数据线向CPU发送需要运算的数据，用控制器来解析指令，并通过控制线发出控制信号；主存储器通过数据线与外设传递数据。</p><p>关于计算机硬件体系的布局如下：</p><p><img src="https://gitee.com/nighost/image-base-of-blog/raw/master/%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%8E%8B%E9%81%93%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%861_4.png" alt=""></p><center>    图1-4 计算机硬件体系布局</center><ul><li>CPU由运算器和控制器组成。</li><li>主机不是日常所说的“主机”，主机由CPU和主存储器组成，不包含辅存储器。</li><li>存储器包含主存储器和辅存储器，主存储器是主机的一部分，辅存储器是外设，诸如机械硬盘和固态硬盘。</li></ul><h1 id="2-各部分硬件的工作原理"><a href="#2-各部分硬件的工作原理" class="headerlink" title="2 各部分硬件的工作原理"></a>2 各部分硬件的工作原理</h1><h2 id="2-1-主存储器结构"><a href="#2-1-主存储器结构" class="headerlink" title="2.1 主存储器结构"></a>2.1 主存储器结构</h2><p>主存储器的结构如下：</p><p><img src="https://gitee.com/nighost/image-base-of-blog/raw/master/%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%8E%8B%E9%81%93%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%BE1_5.png" alt=""></p><center>    图1-5 主存储器的逻辑图</center><ul><li>主存储器包含三个部分：存储体、地址寄存器（MAR）、数据寄存器（MDR）。</li><li>存储器里包含了CPU要读入的数据。</li><li>MAR包含了CPU传入要读取的数据的地址。</li><li>MDR包含了CPU需要的数据本身，是从存储体中取出的。</li><li>整个逻辑关系是，CPU给主存储器一个要读取特定数据的信号，主存储器将其解析成地址，并存放在MAR中，然后从存储体取出那个地址的数据，并传输到MDR中，CPU通过MDR读取到这个数据。</li></ul><p><img src="https://gitee.com/nighost/image-base-of-blog/raw/master/%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%8E%8B%E9%81%93%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%BE1_6.png" alt=""></p><center>    图1-6 存储体结构示意图</center><p>存储单元：每个存储单元存放一串二进制代码</p><p>存储字（word）：存储单元中二进制代码的组合</p><p>存储字长：存储单元中二进制代码的位数</p><ul><li>通常一个存储单元存储一个8bit字长整数倍的二进制代码</li></ul><p>存储元：存储二进制的电子元件，每个存储元柯村1bit</p><ul><li>一个字节（Byte）是8bit长度，但一个字（Word）是不同的概念，通常一个字是16bit</li></ul><h2 id="2-2-运算器的基本组成"><a href="#2-2-运算器的基本组成" class="headerlink" title="2.2 运算器的基本组成"></a>2.2 运算器的基本组成</h2><p>运算器：用于实现算术运算（如：加减乘除）、逻辑运算（如：与或非）</p><p><img src="https://gitee.com/nighost/image-base-of-blog/raw/master/%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%8E%8B%E9%81%93%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%BE1_7.png" alt=""></p><center>    图1-7 运算器的基本结构</center><p>ACC：累加器，用于存放操作数，或运算结果。</p><p>MQ：乘商寄存器，在乘、除运算时，用于存放操作数或运算结果。</p><p>X：通用的操作数寄存器，用于存放操作数。</p><p>ALU：算术逻辑单元，通过内部复杂的电路实现算术运算、逻辑运算。</p><h2 id="2-3-控制器的基本组成"><a href="#2-3-控制器的基本组成" class="headerlink" title="2.3 控制器的基本组成"></a>2.3 控制器的基本组成</h2><p><img src="https://gitee.com/nighost/image-base-of-blog/raw/master/%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%8E%8B%E9%81%93%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%BE1_8.png" alt=""></p><center>    图1-8 控制器的基本结构</center><p>CU（Control Unit）：控制单元，分析指令，给出控制信号</p><p>IR（Instruction Register）：指令寄存器，存放当前执行的指令</p><p>PC（Program Counter）：程序计数器，存放下一条指令地址，有自动加1的功能</p><h2 id="2-4-计算机的工作过程"><a href="#2-4-计算机的工作过程" class="headerlink" title="2.4 计算机的工作过程"></a>2.4 计算机的工作过程</h2><p>首先是高级语言</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a=<span class="number">2</span>,b=<span class="number">3</span>,c=<span class="number">1</span>,y=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    y = a*b+c;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>相应的机器语言执行顺序如下：</p><p><img src="https://gitee.com/nighost/image-base-of-blog/raw/master/%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%8E%8B%E9%81%93%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%BE1_9.png" alt=""></p><center>    图1-9 机器语言执行逻辑图</center><p><img src="https://gitee.com/nighost/image-base-of-blog/raw/master/%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%8E%8B%E9%81%93%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%BE1_10.png" alt=""></p><center>    图1-10 基础的计算机体系结构图</center><p>根据图1-10的计算机体系结构，可以得到硬件的计算顺序。</p><ul><li>声明写法：一个处理器加上括号，表示我们针对一个处理器里面的内容，对于M（MAR），MAR代表主存储器地址，表示针对主存储器这个地址的内容的操作</li></ul><p>主存内第一条指令（“取数”指令）如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">初：（PC）=0  指向第一条指令的存储地址，一般初始的PC是0</span><br><span class="line">#1：（PC）指向MAR，导致（MAR）=0，即控制器向主存储器申明接下来要访问的是主存地址是0的数据</span><br><span class="line">#3：M（MAR）指向MDR，导致（MDR）=0000010000000101</span><br><span class="line">#4：（MDR）指向IR，导致（IR）=0000010000000101，即通过数据线将指令从主存储器传输到控制器的IR</span><br><span class="line">#5：OP（IR）指向CU，指令的操作码（前六位）送到CU，CU分析得知，这是“取数”指令，</span><br><span class="line">#6：Ad（IR）指向MAR，指令的地址码送到MAR，导致（MAR）=5</span><br><span class="line">#8：M（MAR）指向MDR，导致（MDR）=0000000000000010</span><br><span class="line">#9：（MDR）指向ACC，导致（ACC）=0000000000000010=2</span><br></pre></td></tr></table></figure><p>主存内第二条指令（“乘法”指令）如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">上一条指令取指令后PC自动+1，（PC）=1，执行后，（ACC）=2</span><br><span class="line">#1：（PC）指向MAR，导致（MAR）=1</span><br><span class="line">#3：M（MAR）指向MDR，导致（MDR）=0001000000000110</span><br><span class="line">#4：（MDR）指向IR，导致（IR）=0001000000000110</span><br><span class="line">#5：OP（IR）指向CU，指令的操作码送到CU，CU分析得知，是“乘法”指令</span><br><span class="line">#6：Ad（IR）指向MAR，指令的地址码送到MAR，导致（MAR）=6</span><br><span class="line">#8:M（MAR）指向MDR，导致（MDR）=0000000000000011</span><br><span class="line">#9：（MDR）指向MQ，导致（MQ）=0000000000000011</span><br><span class="line">#10：（ACC）指向X，导致（X）=2</span><br><span class="line">#11：（MQ）*（X）指向ACC，由ALU实现乘法运算，导致（ACC）=6，如果乘积太大，需要MQ辅助存储</span><br></pre></td></tr></table></figure><p>主存内第三条指令（“加法指令”）如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">上一条指令取指后（PC）=2，，执行后，（ACC）=6</span><br><span class="line">#1：（PC）指向MAR，导致（MAR）=2</span><br><span class="line">#3：M（MAR）指向MDR，导致（MDR）=0000110000000111</span><br><span class="line">#4：（MDR）指向IR，导致（IR）=0000110000000111</span><br><span class="line">#5：OP（IR）指向CU，指令的操作码送到CU，CU分析得知，是“加法”指令</span><br><span class="line">#6：Ad（IR）指向MAR，指令的地址码送到MAR，导致（MAR）=7</span><br><span class="line">#8：M（MAR）指向MDR，导致（MDR）=0000000000000001</span><br><span class="line">#9：（MDR）指向X，导致（X）=0000000000000001</span><br><span class="line">#10：（ACC）+（X）指向ACC，导致（ACC）=7，由ALU实现加法运算</span><br></pre></td></tr></table></figure><ul><li>注意在指令执行的过程中，乘法运算指令是把数据传输到MQ，把ACC内的数据传输到X，再由ALU做算术运算；而加法运算是把数据直接传输到通用操作数寄存器X中，并由ALU主持ACC内数据和X内数据的加法，并把结果直接存储在ACC中。</li></ul><p>主存内第四条指令（“存数”指令）如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">上一条指令取指后（PC）=3，执行后，（ACC）=7</span><br><span class="line">#1：（PC）指向MAR，导致（MAR）=3</span><br><span class="line">#3：M（MAR）指向MDR，导致（MDR）=0000100000001000</span><br><span class="line">#4：（MDR）指向IR，导致（IR）=0000100000001000</span><br><span class="line">#5：OP（IR）指向CU，指令的操作码送到CU，CU分析得知，是“存数”指令</span><br><span class="line">#6：Ad（IR）指向MAR，指令的地址码送到MAR，导致（MAR）=8</span><br><span class="line">#7：（ACC）指向MDR，导致（MAR）=7</span><br><span class="line">#9：（MDR）指向地址为8的存储单元，导致y=7，这里CU通过控制线给存储体一个存储（MDR）的指令，然后传输（MAR）到存储体，最后#9</span><br></pre></td></tr></table></figure><p>主存内第五条指令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">上一条指令取指后（PC）=4，无ACC</span><br><span class="line">#1：（PC）指向MAR，导致（MAR）=4</span><br><span class="line">#3：M（MAR）指向MDR，导致（MDR）=0001100000000000</span><br><span class="line">#4：（MDR）指向IR，导致（IR）=0001100000000000</span><br><span class="line">#5：OP（IR）指向CU，指令的操作码送到CU，CU分析得知，是“停机”指令</span><br><span class="line">（后续利用中断机制通知操作系统终止该进程）</span><br></pre></td></tr></table></figure><ul><li>运算器的核心是ALU，控制器的核心是CU</li></ul><h1 id="3-计算机系统的层次结构"><a href="#3-计算机系统的层次结构" class="headerlink" title="3 计算机系统的层次结构"></a>3 计算机系统的层次结构</h1><p><img src="https://gitee.com/nighost/image-base-of-blog/raw/master/%E7%8E%8B%E9%81%93%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86/%E7%8E%8B%E9%81%93%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E5%9B%BE1_11.png" alt=""></p><center>    图1-11 计算机系统的层次结构</center><ul><li>用户通过高级语言进行程序编写</li><li>高级语言通过编译器翻译成汇编语言</li><li>汇编语言通过汇编器翻译成机器语言</li></ul><p>编译程序：将高级语言编写的源程序全部语句一次全部翻译成机器语言程序，而后在执行机器语言程序（只需翻译一次）</p><p>解释程序：将源程序的一条语句翻译成对应于机器语言的语句，并立即执行。紧接着再翻译下一句（每次执行都要翻译）</p><h2 id="3-1-计算机体系结构和计算机组成原理的差异"><a href="#3-1-计算机体系结构和计算机组成原理的差异" class="headerlink" title="3.1 计算机体系结构和计算机组成原理的差异"></a>3.1 计算机体系结构和计算机组成原理的差异</h2><p>计算机体系结构——机器语言程序员所见到的计算机系统的属性概念性的结构与功能特性（指令系统、数据类型、寻址技术、I/O机理）</p><p>计算机组成原理——实现计算机体系结构所体现的属性，对程序员“透明”（具体指令的实现）</p><h1 id="4-计算机性能指标"><a href="#4-计算机性能指标" class="headerlink" title="4 计算机性能指标"></a>4 计算机性能指标</h1><h2 id="4-1-存储器的性能指标"><a href="#4-1-存储器的性能指标" class="headerlink" title="4.1 存储器的性能指标"></a>4.1 存储器的性能指标</h2><ul><li>一般度量主存储器的容量</li><li>MAR位数反映存储单元的个数（最多支持多少个）</li><li><p>MDR位数=存储字长=每个存储单元的大小</p></li><li><p>有MAR位数决定的存储单元的个数，以及MDR位数代表的存储字长，<strong>二者相乘</strong>可以得到总的存储体的存储容量</p></li><li>一般说MAR为32位，MDR为8位，那么总容量就是$2^{32}*8bit=4GB$</li></ul><p>一些常用单位</p><p>$2^{10}:K\space\space\space 2^{20}:M \space\space\space 2^{30}:G \space\space\space 2^{40}:T$</p><h2 id="4-2-CPU的性能指标"><a href="#4-2-CPU的性能指标" class="headerlink" title="4.2 CPU的性能指标"></a>4.2 CPU的性能指标</h2><p>CPU主频：CPU内数字脉冲信号的振荡的频率</p><p>CPU时钟周期：$CPU主频（时钟频率）=\frac{1}{CPU时钟周期}$</p><p>CPI（Clock cycle Per Instruction）：执行一条指令所需的时钟周期数</p><p>$执行一条指令的耗时=CPI*CPU时钟周期$</p><p>IPS（Instructions Per Second）：每秒执行多少条指令；CPI是执行一条指令所需的时钟周期数，IPS是一秒执行多少指令，主频是一秒有多少个时钟周期，因此$IPS=\frac{主频}{平均CPI}$</p><p>FLOPS（Floating-point Operations Per Second）：每秒执行多少次浮点运算</p><h2 id="4-3-系统整体的性能指标"><a href="#4-3-系统整体的性能指标" class="headerlink" title="4.3 系统整体的性能指标"></a>4.3 系统整体的性能指标</h2><p>数据通路带宽：数据总线一次所能并行传送信息的位数（各硬件部件通过数据总线传输数据）</p><p>吞吐量：指系统在单位时间内处理请求的数量，它取决于信息能多块地输入内存，CPU能多块地取指令，数据能多块地从内存取出或存入，以及所得结果能多块地从内存送到一台外部设备。每一步都和主存相关，因此系统吞吐量由主存的存储周期决定。</p><p>相应时间：指从用户向计算机发送一个请求，到系统对该请求做出响应并获得它所需要的的结果的等待时间。</p><h2 id="4-4-关于计算系统性能的一些问题"><a href="#4-4-关于计算系统性能的一些问题" class="headerlink" title="4.4 关于计算系统性能的一些问题"></a>4.4 关于计算系统性能的一些问题</h2><ul><li>主频高的CPU一定比主频低的CPU快吗？</li></ul><p>不一定，因为除了主频，IPS还受平均CPI的影响。</p><ul><li>若A、B两个CPU的平均CPI相同，那么A一定更快吗？</li></ul><p>也不一定，还会受到指令系统的影响，比如A不支持乘法指令，B支持乘法指令，那么在做乘法时，A要做多次加法。</p><ul><li>基准程序执行得越快说明机器性能越好吗？</li></ul><p>基准程序中的语句存在频度差异，运行结果也不能完全说明问题。</p>]]></content>
      
      
      <categories>
          
          <category> 计算机组成原理 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础数据结构与算法（二）</title>
      <link href="/2021/06/21/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2021/06/21/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本文章主要介绍树的基本操作，代码来自浙大慕课。</p><span id="more"></span><h1 id="树的存储方式"><a href="#树的存储方式" class="headerlink" title="树的存储方式"></a>树的存储方式</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表方式</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    Tree Left;</span><br><span class="line">    Tree Right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 顺序存储方式</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> Left;</span><br><span class="line">    <span class="keyword">int</span> Right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 静态链表方式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    <span class="keyword">int</span> Left;</span><br><span class="line">    <span class="keyword">int</span> Right;</span><br><span class="line">&#125; T1[MaxSize],T2[MaxSize];</span><br></pre></td></tr></table></figure><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">( Tree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( T )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; T-&gt;Data &lt;&lt; endl; <span class="comment">//- 先序遍历 </span></span><br><span class="line">        <span class="built_in">PreOrderTraversal</span>( T-&gt;Left );</span><br><span class="line">        cout &lt;&lt; T-&gt;Data &lt;&lt; endl; <span class="comment">//- 中序遍历</span></span><br><span class="line">        <span class="built_in">PreOrderTraversal</span>( T-&gt;Right );</span><br><span class="line">        cout &lt;&lt; T-&gt;Data &lt;&lt; endl; <span class="comment">//- 后序遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非递归方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">( Tree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree Tmp = T;</span><br><span class="line">    Stack S = <span class="built_in">CreateStack</span>();</span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">IsEmpty</span>(S) || Tmp != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>( Tmp!=<span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; Tmp-&gt;Data &lt;&lt; endl; <span class="comment">//- 先序遍历</span></span><br><span class="line">            <span class="built_in">Push</span>( S,Tmp );</span><br><span class="line">            Tmp = Tmp-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( !<span class="built_in">IsEmpty</span>( S ) )</span><br><span class="line">        &#123;</span><br><span class="line">            Tmp = <span class="built_in">Pop</span>(S);</span><br><span class="line">            cout &lt;&lt; Tmp-&gt;Data &lt;&lt; endl; <span class="comment">//- 中序遍历</span></span><br><span class="line">            Tmp = Tmp-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraversal</span><span class="params">( Tree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree Tmp = T;</span><br><span class="line">    Queue Q = <span class="built_in">CreateQueue</span>();</span><br><span class="line">    <span class="built_in">AddQ</span>(Q,Tmp);</span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">IsEmpty</span>(Q) )</span><br><span class="line">    &#123;</span><br><span class="line">        Tmp = <span class="built_in">DeleteQ</span>( Q );</span><br><span class="line">        cout &lt;&lt; Tmp-&gt;Data &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>( Tmp-&gt;Left != <span class="literal">NULL</span> ) <span class="built_in">AddQ</span>(Q,Tmp-&gt;Left);</span><br><span class="line">        <span class="keyword">if</span>( Tmp-&gt;Right != <span class="literal">NULL</span> ) <span class="built_in">AddQ</span>(Q,Tmp-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="输出二叉树的所有叶结点"><a href="#输出二叉树的所有叶结点" class="headerlink" title="输出二叉树的所有叶结点"></a>输出二叉树的所有叶结点</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintLeaves</span><span class="params">( BinTree BST )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BST)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( BST-&gt;Left == <span class="literal">NULL</span> &amp;&amp; BST-&gt;Right == <span class="literal">NULL</span> )</span><br><span class="line">            cout &lt;&lt; BST-&gt;Data &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">PrintLeaves</span>( BST-&gt;Left );</span><br><span class="line">        <span class="built_in">PrintLeaves</span>( BST-&gt;Right );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="输出二叉树的高度"><a href="#输出二叉树的高度" class="headerlink" title="输出二叉树的高度"></a>输出二叉树的高度</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetHeight</span><span class="params">( BinTree BST )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( BST )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> LeftHeight,RightHeight;</span><br><span class="line">        LeftHeight = <span class="built_in">GetHeight</span>( BST-&gt;Left );</span><br><span class="line">        RightHeight = <span class="built_in">GetHeight</span>( BST-&gt;Right );</span><br><span class="line">        <span class="keyword">int</span> MaxHeight = LeftHeight &gt; RightHeight ? LeftHeight : RightHeight;</span><br><span class="line">        MaxHeight++;</span><br><span class="line">        <span class="keyword">return</span> MaxHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="根据先序和中序序列，确定二叉树"><a href="#根据先序和中序序列，确定二叉树" class="headerlink" title="根据先序和中序序列，确定二叉树"></a>根据先序和中序序列，确定二叉树</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">PreInBulidTree</span><span class="params">( ElementType Pre[],ElementType In[],<span class="keyword">int</span> PreStart,<span class="keyword">int</span> PreEnd,<span class="keyword">int</span> InStart,<span class="keyword">int</span> InEnd )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( PreStart &gt; PreEnd || InStart &gt; InEnd )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> PreRootItem = Pre[PreStart];</span><br><span class="line">    <span class="keyword">int</span> InRootIndex;</span><br><span class="line">    <span class="keyword">int</span> IndexNum = PreEnd - PreStart + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>;i &lt; IndexNum;i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( In[i] == PreRootItem )</span><br><span class="line">        &#123;</span><br><span class="line">            InRootIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> LeftNum = InRootIndex - InStart;</span><br><span class="line">    <span class="keyword">int</span> RightNum = InEnd - InRootIndex;</span><br><span class="line">    BinTree BST = (BinTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct TNode));</span><br><span class="line">    BST-&gt;Data = PreRootItem;</span><br><span class="line">    BST-&gt;Left = <span class="built_in">PreInBuildTree</span>( Pre,In,PreStart+<span class="number">1</span>,PreStart+LeftNum,InStart,InRootIndex<span class="number">-1</span> );</span><br><span class="line">    BST-&gt;Right = <span class="built_in">PreInBuildTree</span>( Pre,In,PreStart+LeftNum+<span class="number">1</span>,PreEnd,InRootIndex+<span class="number">1</span>,InEnd );</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>后续更新AVL、堆和并查集</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础数据结构与算法习题（二）</title>
      <link href="/2021/06/21/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2021/06/21/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>PTA上树的相关习题。</p><span id="more"></span><h1 id="编程题06——树的同构"><a href="#编程题06——树的同构" class="headerlink" title="编程题06——树的同构"></a>编程题06——树的同构</h1><p>给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。</p><p><img src="https://gitee.com/nighost/image-base-of-blog/raw/master/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98/%E7%BC%96%E7%A8%8B%E9%A2%9806%E5%9B%BE1.png" alt=""></p><center>图1</center><p><img src="https://gitee.com/nighost/image-base-of-blog/raw/master/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98/%E7%BC%96%E7%A8%8B%E9%A2%9806%E5%9B%BE2.png" alt=""></p><center>图2</center><p>现给定两棵树，请你判断它们是否是同构的。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入给出2棵二叉树树的信息。对于每棵树，首先在一行中给出一个非负整数<em>N</em> (≤10)，即该树的结点数（此时假设结点从0到<em>N</em>−1编号）；随后<em>N</em>行，第<em>i</em>行对应编号第<em>i</em>个结点，给出该结点中存储的1个英文大写字母、其左孩子结点的编号、右孩子结点的编号。如果孩子结点为空，则在相应位置上给出“-”。给出的数据间用一个空格分隔。注意：题目保证每个结点中存储的字母是不同的。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>如果两棵树是同构的，输出“Yes”，否则输出“No”。</p><h3 id="输入样例1（对应图1）："><a href="#输入样例1（对应图1）：" class="headerlink" title="输入样例1（对应图1）："></a>输入样例1（对应图1）：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">A 1 2</span><br><span class="line">B 3 4</span><br><span class="line">C 5 -</span><br><span class="line">D - -</span><br><span class="line">E 6 -</span><br><span class="line">G 7 -</span><br><span class="line">F - -</span><br><span class="line">H - -</span><br><span class="line">8</span><br><span class="line">G - 4</span><br><span class="line">B 7 6</span><br><span class="line">F - -</span><br><span class="line">A 5 1</span><br><span class="line">H - -</span><br><span class="line">C 0 -</span><br><span class="line">D - -</span><br><span class="line">E 2 -</span><br></pre></td></tr></table></figure><h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h3 id="输入样例2（对应图2）："><a href="#输入样例2（对应图2）：" class="headerlink" title="输入样例2（对应图2）："></a>输入样例2（对应图2）：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">B 5 7</span><br><span class="line">F - -</span><br><span class="line">A 0 3</span><br><span class="line">C 6 -</span><br><span class="line">H - -</span><br><span class="line">D - -</span><br><span class="line">G 4 -</span><br><span class="line">E 1 -</span><br><span class="line">8</span><br><span class="line">D 6 -</span><br><span class="line">B 5 -</span><br><span class="line">E - -</span><br><span class="line">H - -</span><br><span class="line">C 0 2</span><br><span class="line">G - 3</span><br><span class="line">F - -</span><br><span class="line">A 1 4</span><br></pre></td></tr></table></figure><h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Left;</span><br><span class="line">    <span class="keyword">int</span> Right;</span><br><span class="line">    <span class="keyword">char</span> Letter;</span><br><span class="line">&#125; T1[MaxSize],T2[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreateTree</span><span class="params">( <span class="keyword">int</span> N,struct TNode T[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( N == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> Trigger[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> Item,Lef,Rig;</span><br><span class="line">        cin &gt;&gt; Item &gt;&gt; Lef &gt;&gt; Rig;</span><br><span class="line">        T[i].Letter = Item;</span><br><span class="line">        <span class="keyword">if</span>( Lef != <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            T[i].Left = Lef - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            Trigger[Lef-<span class="string">&#x27;0&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T[i].Left = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>( Rig != <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            T[i].Right = Rig - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            Trigger[Rig-<span class="string">&#x27;0&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T[i].Right = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Root;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( Trigger[i] == <span class="number">0</span> )</span><br><span class="line">            Root = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsIsomophic</span><span class="params">( <span class="keyword">int</span> Root1,<span class="keyword">int</span> Root2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Root1 == <span class="number">-1</span> &amp;&amp; Root2 == <span class="number">-1</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>( (Root1 != <span class="number">-1</span> &amp;&amp; Root2 == <span class="number">-1</span>) || (Root1 == <span class="number">-1</span> &amp;&amp; Root2 != <span class="number">-1</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( T1[Root1].Letter != T2[Root2].Letter )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( T1[Root1].Left == <span class="number">-1</span> &amp;&amp; T2[Root2].Left == <span class="number">-1</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">IsIsomophic</span>( T1[Root1].Right,T2[Root2].Right );</span><br><span class="line">    <span class="keyword">if</span>( T1[Root1].Left != <span class="number">-1</span> &amp;&amp; T2[Root2].Left != <span class="number">-1</span> &amp;&amp; </span><br><span class="line">       T1[T1[Root1].Left].Letter == T2[T2[Root2].Left].Letter )</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">IsIsomophic</span>( T1[Root1].Left,T2[Root2].Left ) &amp;&amp; <span class="built_in">IsIsomophic</span>( T1[Root1].Right,T2[Root2].Right );</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">IsIsomophic</span>( T1[Root1].Left,T2[Root2].Right ) &amp;&amp; <span class="built_in">IsIsomophic</span>( T1[Root1].Right,T2[Root2].Left );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">int</span> Root1 = <span class="built_in">CreateTree</span>( N,T1 );</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">int</span> Root2 = <span class="built_in">CreateTree</span>( N,T2 );</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">IsIsomophic</span>( Root1,Root2 ) )</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编程题07——List-Leaves"><a href="#编程题07——List-Leaves" class="headerlink" title="编程题07——List Leaves"></a>编程题07——List Leaves</h1><p>Given a tree, you are supposed to list all the leaves in the order of top down, and left to right.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤10) which is the total number of nodes in the tree — and hence the nodes are numbered from 0 to <em>N</em>−1. Then <em>N</em> lines follow, each corresponds to a node, and gives the indices of the left and right children of the node. If the child does not exist, a “-“ will be put at the position. Any pair of children are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line all the leaves’ indices in the order of top down, and left to right. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">1 -</span><br><span class="line">- -</span><br><span class="line">0 -</span><br><span class="line">2 7</span><br><span class="line">- -</span><br><span class="line">- -</span><br><span class="line">5 -</span><br><span class="line">4 6</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 1 5</span><br></pre></td></tr></table></figure><h3 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    <span class="keyword">int</span> Left;</span><br><span class="line">    <span class="keyword">int</span> Right;</span><br><span class="line">&#125; T[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> <span class="title">Data</span>[<span class="title">MaxSize</span>];</span></span><br><span class="line">    <span class="keyword">int</span> Front,Rear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">( Queue Q )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Q-&gt;Front == Q-&gt;Rear )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddQ</span><span class="params">( Queue Q,<span class="keyword">int</span> Root )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q-&gt;Rear = (Q-&gt;Rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    Q-&gt;Data[Q-&gt;Rear] = T[Root];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct TNode <span class="title">DeleteQ</span><span class="params">( Queue Q )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q-&gt;Front = (Q-&gt;Front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    <span class="keyword">return</span> Q-&gt;Data[Q-&gt;Front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreateTree</span><span class="params">( <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Trigger[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> left,right;</span><br><span class="line">        cin &gt;&gt; left &gt;&gt; right;</span><br><span class="line">        T[i].Data = i;</span><br><span class="line">        <span class="keyword">if</span>( left != <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            T[i].Left = left - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            Trigger[T[i].Left] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            T[i].Left = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( right != <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            T[i].Right = right - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            Trigger[T[i].Right] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            T[i].Right = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Root;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( Trigger[i] == <span class="number">0</span> )</span><br><span class="line">            Root = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">int</span> Root = <span class="built_in">CreateTree</span>( N );</span><br><span class="line">    <span class="keyword">int</span> Leaves[N];</span><br><span class="line">    <span class="keyword">int</span> LeavesCnt = <span class="number">0</span>;</span><br><span class="line">    Queue Q = (Queue)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct QNode));</span><br><span class="line">    Q-&gt;Front = Q-&gt;Rear = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">AddQ</span>( Q, Root );</span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">IsEmpty</span>(Q) )</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> <span class="title">Tmp</span> =</span> <span class="built_in">DeleteQ</span>( Q );</span><br><span class="line">       <span class="keyword">if</span>( Tmp.Left == <span class="number">-1</span> &amp;&amp; Tmp.Right == <span class="number">-1</span> )</span><br><span class="line">           Leaves[LeavesCnt++] = Tmp.Data;</span><br><span class="line">        <span class="keyword">if</span>( Tmp.Left != <span class="number">-1</span> ) <span class="built_in">AddQ</span>( Q,Tmp.Left );</span><br><span class="line">        <span class="keyword">if</span>( Tmp.Right != <span class="number">-1</span> ) <span class="built_in">AddQ</span>( Q,Tmp.Right );</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; Leaves[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;LeavesCnt;i++ )</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; Leaves[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编程题08——Tree-Traversals-Again"><a href="#编程题08——Tree-Traversals-Again" class="headerlink" title="编程题08——Tree Traversals Again"></a>编程题08——Tree Traversals Again</h1><p>An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.</p><p><img src="https://gitee.com/nighost/image-base-of-blog/raw/master/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98/%E7%BC%96%E7%A8%8B%E9%A2%9808%E5%9B%BE1.png" alt=""></p><h3 id="Input-Specification-1"><a href="#Input-Specification-1" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to <em>N</em>). Then 2<em>N</em> lines follow, each describes a stack operation in the format: “Push X” where X is the index of the node being pushed onto the stack; or “Pop” meaning to pop one node from the stack.</p><h3 id="Output-Specification-1"><a href="#Output-Specification-1" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">Push 1</span><br><span class="line">Push 2</span><br><span class="line">Push 3</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Push 4</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Push 5</span><br><span class="line">Push 6</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4 2 6 5 1</span><br></pre></td></tr></table></figure><h3 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    Tree Left;</span><br><span class="line">    Tree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">CreateTree</span><span class="params">( <span class="keyword">int</span>&amp; N )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( N == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    string Str;</span><br><span class="line">    cin &gt;&gt; Str;</span><br><span class="line">    N--;</span><br><span class="line">    <span class="keyword">if</span>( Str == <span class="string">&quot;Push&quot;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        Tree T = (Tree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct TNode));</span><br><span class="line">        cin &gt;&gt; T-&gt;Data;</span><br><span class="line">        T-&gt;Left = <span class="built_in">CreateTree</span>( N );</span><br><span class="line">        T-&gt;Right = <span class="built_in">CreateTree</span>( N );</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span><span class="params">( Tree T,<span class="keyword">int</span> Node[],<span class="keyword">int</span>&amp; cnt )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( T != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">PostOrderTraversal</span>( T-&gt;Left,Node,cnt );</span><br><span class="line">        <span class="built_in">PostOrderTraversal</span>( T-&gt;Right,Node,cnt );</span><br><span class="line">        Node[cnt++] = T-&gt;Data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin &gt;&gt;N;</span><br><span class="line">    <span class="keyword">int</span> RealN = N;</span><br><span class="line">    N *= <span class="number">2</span>;</span><br><span class="line">    Tree T = <span class="built_in">CreateTree</span>( N );</span><br><span class="line">    <span class="comment">//cout &lt;&lt; T-&gt;Left-&gt;Left-&gt;Data &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> Node[RealN];</span><br><span class="line">    <span class="built_in">PostOrderTraversal</span>( T,Node,cnt );</span><br><span class="line">    <span class="comment">//PostOrderTraversal(T);</span></span><br><span class="line">    cout &lt;&lt; Node[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;RealN;i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; Node[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意N是引用传值，最后会递减成0，在建立树之前最好使用一个RealN来存储N。</li></ul><ul><li>下周更新AVL，平衡二叉树的编程作业</li></ul><p><strong>2021年6月28日更新二叉树和平衡二叉树的习题</strong></p><h1 id="函数题03——二叉搜索树的操作集"><a href="#函数题03——二叉搜索树的操作集" class="headerlink" title="函数题03——二叉搜索树的操作集"></a>函数题03——二叉搜索树的操作集</h1><p>本题要求实现给定二叉搜索树的5种常用操作。</p><h3 id="函数接口定义："><a href="#函数接口定义：" class="headerlink" title="函数接口定义："></a>函数接口定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">( BinTree BST )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">( BinTree BST )</span></span>;</span><br></pre></td></tr></table></figure><p>其中<code>BinTree</code>结构定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Position BinTree;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><ul><li>函数<code>Insert</code>将<code>X</code>插入二叉搜索树<code>BST</code>并返回结果树的根结点指针；</li><li>函数<code>Delete</code>将<code>X</code>从二叉搜索树<code>BST</code>中删除，并返回结果树的根结点指针；如果<code>X</code>不在树中，则打印一行<code>Not Found</code>并返回原树的根结点指针；</li><li>函数<code>Find</code>在二叉搜索树<code>BST</code>中找到<code>X</code>，返回该结点的指针；如果找不到则返回空指针；</li><li>函数<code>FindMin</code>返回二叉搜索树<code>BST</code>中最小元结点的指针；</li><li>函数<code>FindMax</code>返回二叉搜索树<code>BST</code>中最大元结点的指针。</li></ul><h3 id="裁判测试程序样例："><a href="#裁判测试程序样例：" class="headerlink" title="裁判测试程序样例："></a>裁判测试程序样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Position</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> Position BinTree;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreorderTraversal</span><span class="params">( BinTree BT )</span></span>; <span class="comment">/* 先序遍历，由裁判实现，细节不表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InorderTraversal</span><span class="params">( BinTree BT )</span></span>;  <span class="comment">/* 中序遍历，由裁判实现，细节不表 */</span></span><br><span class="line"></span><br><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">( BinTree BST )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">( BinTree BST )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinTree BST, MinP, MaxP, Tmp;</span><br><span class="line">    ElementType X;</span><br><span class="line">    <span class="keyword">int</span> N, i;</span><br><span class="line"></span><br><span class="line">    BST = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">        BST = <span class="built_in">Insert</span>(BST, X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Preorder:&quot;</span>); <span class="built_in">PreorderTraversal</span>(BST); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    MinP = <span class="built_in">FindMin</span>(BST);</span><br><span class="line">    MaxP = <span class="built_in">FindMax</span>(BST);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">        Tmp = <span class="built_in">Find</span>(BST, X);</span><br><span class="line">        <span class="keyword">if</span> (Tmp == <span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d is not found\n&quot;</span>, X);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is found\n&quot;</span>, Tmp-&gt;Data);</span><br><span class="line">            <span class="keyword">if</span> (Tmp==MinP) <span class="built_in">printf</span>(<span class="string">&quot;%d is the smallest key\n&quot;</span>, Tmp-&gt;Data);</span><br><span class="line">            <span class="keyword">if</span> (Tmp==MaxP) <span class="built_in">printf</span>(<span class="string">&quot;%d is the largest key\n&quot;</span>, Tmp-&gt;Data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">        BST = <span class="built_in">Delete</span>(BST, X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Inorder:&quot;</span>); <span class="built_in">InorderTraversal</span>(BST); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">5 8 6 2 4 1 0 10 9 7</span><br><span class="line">5</span><br><span class="line">6 3 10 0 5</span><br><span class="line">5</span><br><span class="line">5 7 0 10 3</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Preorder: 5 2 1 0 4 8 6 7 10 9</span><br><span class="line">6 is found</span><br><span class="line">3 is not found</span><br><span class="line">10 is found</span><br><span class="line">10 is the largest key</span><br><span class="line">0 is found</span><br><span class="line">0 is the smallest key</span><br><span class="line">5 is found</span><br><span class="line">Not Found</span><br><span class="line">Inorder: 1 2 4 6 8 9</span><br></pre></td></tr></table></figure><h3 id="答案："><a href="#答案：" class="headerlink" title="答案："></a>答案：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">( BinTree BST )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( BST == <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    Position Tmp = BST;</span><br><span class="line">    <span class="keyword">while</span>( Tmp-&gt;Left != <span class="literal">NULL</span> )</span><br><span class="line">        Tmp = Tmp-&gt;Left;</span><br><span class="line">    <span class="keyword">return</span> Tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">( BinTree BST )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( BST == <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    Position Tmp = BST;</span><br><span class="line">    <span class="keyword">while</span>( Tmp-&gt;Right != <span class="literal">NULL</span> )</span><br><span class="line">        Tmp = Tmp-&gt;Right;</span><br><span class="line">    <span class="keyword">return</span> Tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( BinTree BST, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( BST == <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>( BST )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( BST-&gt;Data == X )</span><br><span class="line">            <span class="keyword">return</span> BST;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( X &lt; BST-&gt;Data )</span><br><span class="line">            BST = BST-&gt;Left;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            BST = BST-&gt;Right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">( BinTree BST, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( BST == <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        BST = (BinTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct TNode));</span><br><span class="line">        BST-&gt;Left = BST-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">        BST-&gt;Data = X;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( X &lt; BST-&gt;Data )</span><br><span class="line">        &#123;</span><br><span class="line">            BST-&gt;Left = <span class="built_in">Insert</span>( BST-&gt;Left,X );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( X &gt; BST-&gt;Data )</span><br><span class="line">        &#123;</span><br><span class="line">            BST-&gt;Right = <span class="built_in">Insert</span>( BST-&gt;Right,X );</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">( BinTree BST, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( BST == <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not Found\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( X &lt; BST-&gt;Data )</span><br><span class="line">    &#123;</span><br><span class="line">        BST-&gt;Left = <span class="built_in">Delete</span>( BST-&gt;Left,X );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( X &gt; BST-&gt;Data )</span><br><span class="line">    &#123;</span><br><span class="line">        BST-&gt;Right = <span class="built_in">Delete</span>( BST-&gt;Right,X );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( BST-&gt;Left != <span class="literal">NULL</span> &amp;&amp; BST-&gt;Right != <span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            BinTree Tmp = <span class="built_in">FindMin</span>( BST-&gt;Right );</span><br><span class="line">            BST-&gt;Data = Tmp-&gt;Data;</span><br><span class="line">            BST-&gt;Right = <span class="built_in">Delete</span>( BST-&gt;Right,BST-&gt;Data );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            BinTree Tmp = <span class="literal">NULL</span>;</span><br><span class="line">            <span class="keyword">if</span>( BST-&gt;Left == <span class="literal">NULL</span> &amp;&amp; BST-&gt;Right == <span class="literal">NULL</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">free</span>(BST);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>( BST-&gt;Left != <span class="literal">NULL</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                Tmp = BST-&gt;Left;</span><br><span class="line">                <span class="built_in">free</span>( BST );</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                Tmp = BST-&gt;Right;</span><br><span class="line">                <span class="built_in">free</span>( BST );</span><br><span class="line">            &#125;</span><br><span class="line">            BST = Tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编程题09——是否同一颗二叉搜索树"><a href="#编程题09——是否同一颗二叉搜索树" class="headerlink" title="编程题09——是否同一颗二叉搜索树"></a>编程题09——是否同一颗二叉搜索树</h1><p>给定一个插入序列就可以唯一确定一棵二叉搜索树。然而，一棵给定的二叉搜索树却可以由多种不同的插入序列得到。例如分别按照序列{2, 1, 3}和{2, 3, 1}插入初始为空的二叉搜索树，都得到一样的结果。于是对于输入的各种插入序列，你需要判断它们是否能生成一样的二叉搜索树。</p><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入包含若干组测试数据。每组数据的第1行给出两个正整数<em>N</em> (≤10)和<em>L</em>，分别是每个序列插入元素的个数和需要检查的序列个数。第2行给出<em>N</em>个以空格分隔的正整数，作为初始插入序列。最后<em>L</em>行，每行给出<em>N</em>个插入的元素，属于<em>L</em>个需要检查的序列。</p><p>简单起见，我们保证每个插入序列都是1到<em>N</em>的一个排列。当读到<em>N</em>为0时，标志输入结束，这组数据不要处理。</p><h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>对每一组需要检查的序列，如果其生成的二叉搜索树跟对应的初始序列生成的一样，输出“Yes”，否则输出“No”。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">4 2</span><br><span class="line">3 1 4 2</span><br><span class="line">3 4 1 2</span><br><span class="line">3 2 4 1</span><br><span class="line">2 1</span><br><span class="line">2 1</span><br><span class="line">1 2</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br><span class="line">No</span><br><span class="line">No</span><br></pre></td></tr></table></figure><h3 id="答案：-1"><a href="#答案：-1" class="headerlink" title="答案："></a>答案：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">BinTree</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">( BinTree BST,ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( BST == <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        BST = (BinTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct TNode));</span><br><span class="line">        BST-&gt;Left = BST-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">        BST-&gt;Data = X;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( X &lt; BST-&gt;Data )</span><br><span class="line">            BST-&gt;Left = <span class="built_in">Insert</span>( BST-&gt;Left,X );</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( X &gt; BST-&gt;Data )</span><br><span class="line">            BST-&gt;Right = <span class="built_in">Insert</span>( BST-&gt;Right,X );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BinTree <span class="title">CreateTree</span><span class="params">( <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinTree BST = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>( N &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        ElementType Dat;</span><br><span class="line">        cin &gt;&gt; Dat;</span><br><span class="line">        BST = <span class="built_in">Insert</span>( BST,Dat );</span><br><span class="line">        N--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Compare</span><span class="params">( BinTree A1,BinTree A2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( A1 == <span class="literal">NULL</span> &amp;&amp; A2 == <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( A1 == <span class="literal">NULL</span> || A2 == <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( A1-&gt;Data == A2-&gt;Data )</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Compare</span>( A1-&gt;Left,A2-&gt;Left ) &amp;&amp; <span class="built_in">Compare</span>( A1-&gt;Right,A2-&gt;Right );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">BinTree <span class="title">DeleteTree</span><span class="params">( BinTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( T-&gt;Left != <span class="literal">NULL</span> )</span><br><span class="line">        T-&gt;Left = <span class="built_in">DeleteTree</span>( T-&gt;Left );</span><br><span class="line">    <span class="keyword">if</span>( T-&gt;Right != <span class="literal">NULL</span> )</span><br><span class="line">        T-&gt;Right = <span class="built_in">DeleteTree</span>( T-&gt;Right );</span><br><span class="line">    <span class="built_in">free</span>(T);</span><br><span class="line">    T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N,L;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">while</span>( N &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; L;</span><br><span class="line">        BinTree BaseTree = <span class="built_in">CreateTree</span>(N);</span><br><span class="line">        <span class="keyword">while</span>( L &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            BinTree CompTree = <span class="built_in">CreateTree</span>(N);</span><br><span class="line">            <span class="keyword">if</span>( <span class="built_in">Compare</span>( BaseTree,CompTree ) )</span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">            CompTree = <span class="built_in">DeleteTree</span>( CompTree );</span><br><span class="line">            <span class="comment">//CompTree = NULL;</span></span><br><span class="line">            L--;</span><br><span class="line">        &#125;</span><br><span class="line">        BaseTree = <span class="built_in">DeleteTree</span>( BaseTree );</span><br><span class="line">        <span class="comment">//BaseTree = NULL;</span></span><br><span class="line">        cin &gt;&gt; N;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><h1 id="编程题10——Root-of-AVL-Tree"><a href="#编程题10——Root-of-AVL-Tree" class="headerlink" title="编程题10——Root of AVL Tree"></a>编程题10——Root of AVL Tree</h1><p>An AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; if at any time they differ by more than one, rebalancing is done to restore this property. Figures 1-4 illustrate the rotation rules.</p><p><img src="https://gitee.com/nighost/image-base-of-blog/raw/master/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98/%E7%BC%96%E7%A8%8B%E9%A2%9810%E5%9B%BE1.jpg" alt=""></p><p><img src="https://gitee.com/nighost/image-base-of-blog/raw/master/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98/%E7%BC%96%E7%A8%8B%E9%A2%9810%E5%9B%BE2.jpg" alt=""></p><p><img src="https://gitee.com/nighost/image-base-of-blog/raw/master/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98/%E7%BC%96%E7%A8%8B%E9%A2%9810%E5%9B%BE3.jpg" alt=""></p><p><img src="https://gitee.com/nighost/image-base-of-blog/raw/master/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98/%E7%BC%96%E7%A8%8B%E9%A2%9810%E5%9B%BE4.jpg" alt=""></p><p>Now given a sequence of insertions, you are supposed to tell the root of the resulting AVL tree.</p><h3 id="Input-Specification-2"><a href="#Input-Specification-2" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤20) which is the total number of keys to be inserted. Then <em>N</em> distinct integer keys are given in the next line. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification-2"><a href="#Output-Specification-2" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the root of the resulting AVL tree in one line.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input 1:"></a>Sample Input 1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">88 70 61 96 120</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output 1:"></a>Sample Output 1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">70</span><br></pre></td></tr></table></figure><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input 2:"></a>Sample Input 2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">7</span><br><span class="line">88 70 61 96 120 90 65</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output 2:"></a>Sample Output 2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">88</span><br></pre></td></tr></table></figure><h3 id="答案：-2"><a href="#答案：-2" class="headerlink" title="答案："></a>答案：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">AVLTree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    AVLTree Left;</span><br><span class="line">    AVLTree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Max</span><span class="params">( <span class="keyword">int</span> A,<span class="keyword">int</span> B )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> A&gt;B?A:B;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetHeight</span><span class="params">( AVLTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( T == <span class="literal">NULL</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> LeftHeight = <span class="built_in">GetHeight</span>( T-&gt;Left );</span><br><span class="line">    <span class="keyword">int</span> RightHeight = <span class="built_in">GetHeight</span>( T-&gt;Right );</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Max</span>( LeftHeight,RightHeight ) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLTree <span class="title">SingleLeftRotation</span><span class="params">( AVLTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLTree Tmp = T-&gt;Left;</span><br><span class="line">    T-&gt;Left = Tmp-&gt;Right;</span><br><span class="line">    Tmp-&gt;Right = T;</span><br><span class="line">    <span class="keyword">return</span> Tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLTree <span class="title">SingleRightRotation</span><span class="params">( AVLTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLTree Tmp = T-&gt;Right;</span><br><span class="line">    T-&gt;Right = Tmp-&gt;Left;</span><br><span class="line">    Tmp-&gt;Left = T;</span><br><span class="line">    <span class="keyword">return</span> Tmp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLTree <span class="title">DoubleLeftRightRotation</span><span class="params">( AVLTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T-&gt;Left = <span class="built_in">SingleRightRotation</span>( T-&gt;Left );</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">SingleLeftRotation</span>( T );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLTree <span class="title">DoubleRightLeftRotation</span><span class="params">( AVLTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T-&gt;Right = <span class="built_in">SingleLeftRotation</span>( T-&gt;Right );</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">SingleRightRotation</span>( T );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLTree <span class="title">LeftBalance</span><span class="params">( AVLTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLTree LeftT = T-&gt;Left;</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">GetHeight</span>( LeftT-&gt;Left ) - <span class="built_in">GetHeight</span>( LeftT-&gt;Right ) &gt;= <span class="number">1</span> )</span><br><span class="line">        T = <span class="built_in">SingleLeftRotation</span>( T );</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        T = <span class="built_in">DoubleLeftRightRotation</span>( T );</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLTree <span class="title">RightBalance</span><span class="params">( AVLTree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    AVLTree RightT = T-&gt;Right;</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">GetHeight</span>( RightT-&gt;Right ) - <span class="built_in">GetHeight</span>( RightT-&gt;Left ) &gt;=<span class="number">1</span> )</span><br><span class="line">        T = <span class="built_in">SingleRightRotation</span>( T );</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        T = <span class="built_in">DoubleRightLeftRotation</span>( T );</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">AVLTree <span class="title">Insert</span><span class="params">( AVLTree T,ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( T == <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        T = (AVLTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct TNode));</span><br><span class="line">        T-&gt;Left = T-&gt;Right = <span class="literal">NULL</span>;</span><br><span class="line">        T-&gt;Data = X;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span>( X &gt; T-&gt;Data )</span><br><span class="line">        &#123;</span><br><span class="line">            T-&gt;Left = <span class="built_in">Insert</span>( T-&gt;Left,X );</span><br><span class="line">            <span class="keyword">if</span>( <span class="built_in">GetHeight</span>( T-&gt;Left ) - <span class="built_in">GetHeight</span>( T-&gt;Right ) &gt; <span class="number">1</span> )</span><br><span class="line">                T = <span class="built_in">LeftBalance</span>(T);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( X &lt; T-&gt;Data )</span><br><span class="line">        &#123;</span><br><span class="line">            T-&gt;Right = <span class="built_in">Insert</span>( T-&gt;Right,X );</span><br><span class="line">            <span class="keyword">if</span>( <span class="built_in">GetHeight</span>( T-&gt;Right ) - <span class="built_in">GetHeight</span>( T-&gt;Left ) &gt; <span class="number">1</span> )</span><br><span class="line">                T = <span class="built_in">RightBalance</span>(T);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> T;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    AVLTree T = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>( N &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        ElementType Item;</span><br><span class="line">        cin &gt;&gt; Item;</span><br><span class="line">        T = <span class="built_in">Insert</span>( T,Item );</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        N--;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; T-&gt;Data &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编程题11——Complete-Binary-Search-Tree"><a href="#编程题11——Complete-Binary-Search-Tree" class="headerlink" title="编程题11——Complete Binary Search Tree"></a>编程题11——Complete Binary Search Tree</h1><p>A Binary Search Tree (BST) is recursively defined as a binary tree which has the following properties:</p><p>The left subtree of a node contains only nodes with keys less than the node’s key.</p><p>The right subtree of a node contains only nodes with keys greater than or equal to the node’s key.</p><p>Both the left and right subtrees must also be binary search trees.</p><p>A Complete Binary Tree (CBT) is a tree that is completely filled, with the possible exception of the bottom level, which is filled from left to right.</p><p>Now given a sequence of distinct non-negative integer keys, a unique BST can be constructed if it is required that the tree must also be a CBT. You are supposed to output the level order traversal sequence of this BST.</p><h3 id="Input-Specification-3"><a href="#Input-Specification-3" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤1000). Then <em>N</em> distinct non-negative integer keys are given in the next line. All the numbers in a line are separated by a space and are no greater than 2000.</p><h3 id="Output-Specification-3"><a href="#Output-Specification-3" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line the level order traversal sequence of the corresponding complete binary search tree. All the numbers in a line must be separated by a space, and there must be no extra space at the end of the line.</p><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">1 2 3 4 5 6 7 8 9 0</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">6 3 8 1 5 7 9 0 2 4</span><br></pre></td></tr></table></figure><h3 id="答案：-3"><a href="#答案：-3" class="headerlink" title="答案："></a>答案：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CompBinTree</span><span class="params">( ElementType Data[],ElementType Tree[],<span class="keyword">int</span> Start,<span class="keyword">int</span> End,<span class="keyword">int</span> Root,<span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( End == Start )</span><br><span class="line">    &#123;</span><br><span class="line">        Tree[Root] = Data[Start];</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Length = End - Start + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> Cnt = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( Length &gt; ( Cnt * <span class="number">2</span> + <span class="number">1</span> ) )</span><br><span class="line">    &#123;</span><br><span class="line">        Cnt = Cnt * <span class="number">2</span> + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> LeftLen;</span><br><span class="line">    <span class="keyword">int</span> RightLen;</span><br><span class="line">    <span class="keyword">if</span>( Length &lt;= Cnt + (Cnt<span class="number">-1</span>)/<span class="number">2</span> + <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        RightLen = (Cnt<span class="number">-1</span>)/<span class="number">2</span>;</span><br><span class="line">        LeftLen = Length - RightLen - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        LeftLen = Cnt;</span><br><span class="line">        RightLen = Length - LeftLen - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Tree[Root] = Data[Start+LeftLen];</span><br><span class="line">    <span class="keyword">if</span>( (Root+<span class="number">1</span>)*<span class="number">2</span><span class="number">-1</span> &lt;= N )  <span class="built_in">CompBinTree</span>( Data,Tree,Start,Start+LeftLen<span class="number">-1</span>,(Root+<span class="number">1</span>)*<span class="number">2</span><span class="number">-1</span>,N );</span><br><span class="line">    <span class="keyword">if</span>( (Root+<span class="number">1</span>)*<span class="number">2</span> &lt;= N )  <span class="built_in">CompBinTree</span>( Data,Tree,Start+LeftLen+<span class="number">1</span>,End,(Root+<span class="number">1</span>)*<span class="number">2</span>,N );</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    ElementType Data[N];</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; Data[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;N;j++ )</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>( Data[i] &gt; Data[j] )</span><br><span class="line">            &#123;</span><br><span class="line">                ElementType Item = Data[i];</span><br><span class="line">                Data[i] = Data[j];</span><br><span class="line">                Data[j] = Item;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    ElementType Tree[N];</span><br><span class="line">    <span class="keyword">int</span> Start = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> End = N<span class="number">-1</span>;</span><br><span class="line">    <span class="comment">//int Root = 0;</span></span><br><span class="line">    <span class="built_in">CompBinTree</span>( Data,Tree,Start,End,<span class="number">0</span>,N );</span><br><span class="line">    cout &lt;&lt; Tree[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++ )</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; Tree[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>下周更新哈夫曼树和并查集习题</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础数据结构与算法习题（一）</title>
      <link href="/2021/06/17/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2021/06/17/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>PTA上第一章和第二章的习题。</p><span id="more"></span><h1 id="函数题01——二分查找"><a href="#函数题01——二分查找" class="headerlink" title="函数题01——二分查找"></a>函数题01——二分查找</h1><p>本题要求实现二分查找算法。</p><h3 id="函数接口定义："><a href="#函数接口定义：" class="headerlink" title="函数接口定义："></a>函数接口定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">BinarySearch</span><span class="params">( List L, ElementType X )</span></span>;</span><br></pre></td></tr></table></figure><p>其中<code>List</code>结构定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    Position Last; <span class="comment">/* 保存线性表中最后一个元素的位置 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>L</code>是用户传入的一个线性表，其中<code>ElementType</code>元素可以通过&gt;、==、&lt;进行比较，并且题目保证传入的数据是递增有序的。函数<code>BinarySearch</code>要查找<code>X</code>在<code>Data</code>中的位置，即数组下标（注意：元素从下标1开始存储）。找到则返回下标，否则返回一个特殊的失败标记<code>NotFound</code>。</p><h3 id="裁判测试程序样例："><a href="#裁判测试程序样例：" class="headerlink" title="裁判测试程序样例："></a>裁判测试程序样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NotFound 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    Position Last; <span class="comment">/* 保存线性表中最后一个元素的位置 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">ReadInput</span><span class="params">()</span></span>; <span class="comment">/* 裁判实现，细节不表。元素从下标1开始存储 */</span></span><br><span class="line"><span class="function">Position <span class="title">BinarySearch</span><span class="params">( List L, ElementType X )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L;</span><br><span class="line">    ElementType X;</span><br><span class="line">    Position P;</span><br><span class="line"></span><br><span class="line">    L = <span class="built_in">ReadInput</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">    P = <span class="built_in">BinarySearch</span>( L, X );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, P);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure><h3 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">12 31 55 89 101</span><br><span class="line">31</span><br></pre></td></tr></table></figure><h3 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">26 78 233</span><br><span class="line">31</span><br></pre></td></tr></table></figure><h3 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">BinarySearch</span><span class="params">( List L, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Start = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> End = L-&gt;Last;</span><br><span class="line">    <span class="comment">//int Middle = ( Start + End )/2;</span></span><br><span class="line">    <span class="keyword">while</span>( Start &lt;= End )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> Middle = ( Start + End )/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>( L-&gt;Data[Middle] == X )</span><br><span class="line">            <span class="keyword">return</span> Middle;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( L-&gt;Data[Middle] &lt; X )</span><br><span class="line">            Start = Middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            End = Middle - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NotFound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数题02——线性结构1：两个有序链表序列的合并"><a href="#函数题02——线性结构1：两个有序链表序列的合并" class="headerlink" title="函数题02——线性结构1：两个有序链表序列的合并"></a>函数题02——线性结构1：两个有序链表序列的合并</h1><p>本题要求实现一个函数，将两个链表表示的递增整数序列合并为一个非递减的整数序列。</p><h3 id="函数接口定义：-1"><a href="#函数接口定义：-1" class="headerlink" title="函数接口定义："></a>函数接口定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">Merge</span><span class="params">( List L1, List L2 )</span></span>;</span><br></pre></td></tr></table></figure><p>其中<code>List</code>结构定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ElementType Data; <span class="comment">/* 存储结点数据 */</span></span><br><span class="line">    PtrToNode   Next; <span class="comment">/* 指向下一个结点的指针 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List; <span class="comment">/* 定义单链表类型 */</span></span><br></pre></td></tr></table></figure><p><code>L1</code>和<code>L2</code>是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数<code>Merge</code>要将<code>L1</code>和<code>L2</code>合并为一个非递减的整数序列。应直接使用原序列中的结点，返回归并后的带头结点的链表头指针。</p><h3 id="裁判测试程序样例：-1"><a href="#裁判测试程序样例：-1" class="headerlink" title="裁判测试程序样例："></a>裁判测试程序样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToNode   Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Read</span><span class="params">()</span></span>; <span class="comment">/* 细节在此不表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">( List L )</span></span>; <span class="comment">/* 细节在此不表；空链表将输出NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Merge</span><span class="params">( List L1, List L2 )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L1, L2, L;</span><br><span class="line">    L1 = <span class="built_in">Read</span>();</span><br><span class="line">    L2 = <span class="built_in">Read</span>();</span><br><span class="line">    L = <span class="built_in">Merge</span>(L1, L2);</span><br><span class="line">    <span class="built_in">Print</span>(L);</span><br><span class="line">    <span class="built_in">Print</span>(L1);</span><br><span class="line">    <span class="built_in">Print</span>(L2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 3 5</span><br><span class="line">5</span><br><span class="line">2 4 6 8 10</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 8 10 </span><br><span class="line">NULL</span><br><span class="line">NULL</span><br></pre></td></tr></table></figure><h3 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">Merge</span><span class="params">( List L1, List L2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct Node));</span><br><span class="line">    List TempL = L;</span><br><span class="line">    L-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>( L1-&gt;Next != <span class="literal">NULL</span> &amp;&amp; L2-&gt;Next != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( L1-&gt;Next-&gt;Data &lt;= L2-&gt;Next-&gt;Data )</span><br><span class="line">        &#123;</span><br><span class="line">            TempL-&gt;Next = L1-&gt;Next;</span><br><span class="line">            TempL = TempL-&gt;Next;</span><br><span class="line">            L1-&gt;Next = TempL-&gt;Next;</span><br><span class="line">            TempL-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            TempL-&gt;Next = L2-&gt;Next;</span><br><span class="line">            TempL = TempL-&gt;Next;</span><br><span class="line">            L2-&gt;Next = TempL-&gt;Next;</span><br><span class="line">            TempL-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>( L1-&gt;Next != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        TempL-&gt;Next = L1-&gt;Next;</span><br><span class="line">        L1-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>( L2-&gt;Next != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        TempL-&gt;Next = L2-&gt;Next;</span><br><span class="line">        L2-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编程题01——最大子列和问题"><a href="#编程题01——最大子列和问题" class="headerlink" title="编程题01——最大子列和问题"></a>编程题01——最大子列和问题</h1><p>给定<em>K</em>个整数组成的序列{ <em>N</em>1, <em>N</em>2, …, <em>N**K</em> }，“连续子列”被定义为{ <em>N**i</em>, <em>N**i</em>+1, …, <em>N**j</em> }，其中 1≤<em>i</em>≤<em>j</em>≤<em>K</em>。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。</p><p>本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：</p><ul><li>数据1：与样例等价，测试基本正确性；</li><li>数据2：102个随机整数；</li><li>数据3：103个随机整数；</li><li>数据4：104个随机整数；</li><li>数据5：105个随机整数；</li></ul><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出正整数<em>K</em> (≤100000)；第2行给出<em>K</em>个整数，其间以空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">-2 11 -4 13 -5 -2</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><h3 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSubSeq</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">int</span> Max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> Temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>( N &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> Input;</span><br><span class="line">        cin &gt;&gt; Input;</span><br><span class="line">        Temp += Input;</span><br><span class="line">        <span class="keyword">if</span>( Temp &gt; Max )</span><br><span class="line">        &#123;</span><br><span class="line">            Max = Temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( Temp &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            Temp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        N--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Max = <span class="number">0</span>;</span><br><span class="line">    Max = <span class="built_in">MaxSubSeq</span>();</span><br><span class="line">    cout &lt;&lt; Max &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编程题02——Maximum-Subsequence-Sum"><a href="#编程题02——Maximum-Subsequence-Sum" class="headerlink" title="编程题02——Maximum Subsequence Sum"></a>编程题02——Maximum Subsequence Sum</h1><p>Given a sequence of <em>K</em> integers { <em>N</em>1, <em>N</em>2, …, <em>N**K</em> }. A continuous subsequence is defined to be { <em>N**i</em>, <em>N**i</em>+1, …, <em>N**j</em> } where 1≤<em>i</em>≤<em>j</em>≤<em>K</em>. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.</p><p>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer <em>K</em> (≤10000). The second line contains <em>K</em> numbers, separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices <em>i</em> and <em>j</em> (as shown by the sample case). If all the <em>K</em> numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">-10 1 2 3 4 -5 -23 3 7 -21</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 1 4</span><br></pre></td></tr></table></figure><h3 id="答案-3"><a href="#答案-3" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaxSubSeq</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">int</span> TempN;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    TempN = N;</span><br><span class="line">    <span class="keyword">int</span> Max = <span class="number">0</span>; <span class="keyword">int</span> Temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> Start,TempStart;</span><br><span class="line">    <span class="keyword">int</span> End,TempEnd;</span><br><span class="line">    <span class="keyword">int</span> TempTrigger = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ZeroCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> NegCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> First,Last;</span><br><span class="line">    <span class="keyword">while</span>( TempN &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> Input;</span><br><span class="line">        cin &gt;&gt; Input;</span><br><span class="line">        <span class="keyword">if</span>( TempN == N )</span><br><span class="line">            First = Input;</span><br><span class="line">        <span class="keyword">if</span>( TempN == <span class="number">1</span> )</span><br><span class="line">            Last = Input;</span><br><span class="line">        <span class="keyword">if</span>( Input &lt; <span class="number">0</span> )</span><br><span class="line">            NegCnt++;</span><br><span class="line">        <span class="keyword">if</span>( Input == <span class="number">0</span> )</span><br><span class="line">            ZeroCnt++;</span><br><span class="line">        <span class="keyword">if</span>( TempTrigger == <span class="number">1</span> )</span><br><span class="line">            TempStart = Input;</span><br><span class="line">        TempTrigger = <span class="number">0</span>;</span><br><span class="line">        TempEnd = Input;</span><br><span class="line">        Temp += Input;</span><br><span class="line">        <span class="keyword">if</span>( Temp &gt; Max )</span><br><span class="line">        &#123;</span><br><span class="line">            Max = Temp;</span><br><span class="line">            Start = TempStart;</span><br><span class="line">            End = TempEnd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( Temp &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            Temp = <span class="number">0</span>;</span><br><span class="line">            TempTrigger = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TempN--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( NegCnt == N )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0 &quot;</span> &lt;&lt; First &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; Last &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( NegCnt + ZeroCnt == N )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0 0 0&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; Max &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; Start &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; End &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MaxSubSeq</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编程题03——线性结构：一元多项式的乘法与加法运算"><a href="#编程题03——线性结构：一元多项式的乘法与加法运算" class="headerlink" title="编程题03——线性结构：一元多项式的乘法与加法运算"></a>编程题03——线性结构：一元多项式的乘法与加法运算</h1><p>设计函数分别求两个一元多项式的乘积与和。</p><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p><h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出<code>0 0</code>。</p><h3 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 3 4 -5 2  6 1  -2 0</span><br><span class="line">3 5 20  -7 4  3 1</span><br></pre></td></tr></table></figure><h3 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1</span><br><span class="line">5 20 -4 4 -5 2 9 1 -2 0</span><br></pre></td></tr></table></figure><h3 id="答案-4"><a href="#答案-4" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElementType Coef;</span><br><span class="line">    ElementType Pow;</span><br><span class="line">    List Next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">CreateList</span><span class="params">( List L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    List Tem = L;</span><br><span class="line">    <span class="keyword">if</span>( N &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>( N &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            List NewList = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">            cin &gt;&gt; NewList-&gt;Coef &gt;&gt; NewList-&gt;Pow;</span><br><span class="line">            NewList-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">            Tem-&gt;Next = NewList;</span><br><span class="line">            Tem = NewList;</span><br><span class="line">            N--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        List NewList = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">        NewList-&gt;Coef = NewList-&gt;Pow = <span class="number">0</span>;</span><br><span class="line">        NewList-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">        Tem-&gt;Next = NewList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">AddList</span><span class="params">( List L1,List L2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">    L-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    List Tem = L;</span><br><span class="line">    List TemL1 = L1-&gt;Next;</span><br><span class="line">    List TemL2 = L2-&gt;Next;</span><br><span class="line">    <span class="keyword">while</span>( TemL1!=<span class="literal">NULL</span> &amp;&amp; TemL2!=<span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( TemL1-&gt;Pow &gt; TemL2-&gt;Pow )</span><br><span class="line">        &#123;</span><br><span class="line">            List NewList = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">            NewList-&gt;Coef = TemL1-&gt;Coef;</span><br><span class="line">            NewList-&gt;Pow = TemL1-&gt;Pow;</span><br><span class="line">            NewList-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">            TemL1 = TemL1-&gt;Next;</span><br><span class="line">            Tem-&gt;Next = NewList;</span><br><span class="line">            Tem = Tem-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( TemL1-&gt;Pow &lt; TemL2-&gt;Pow )</span><br><span class="line">        &#123;</span><br><span class="line">            List NewList = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">            NewList-&gt;Coef = TemL2-&gt;Coef;</span><br><span class="line">            NewList-&gt;Pow = TemL2-&gt;Pow;</span><br><span class="line">            NewList-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">            TemL2 = TemL2-&gt;Next;</span><br><span class="line">            Tem-&gt;Next = NewList;</span><br><span class="line">            Tem = Tem-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>( TemL1-&gt;Coef + TemL2-&gt;Coef != <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                List NewList = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">                NewList-&gt;Coef = TemL1-&gt;Coef + TemL2-&gt;Coef;</span><br><span class="line">                NewList-&gt;Pow = TemL1-&gt;Pow;</span><br><span class="line">                NewList-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">                TemL1 = TemL1-&gt;Next;</span><br><span class="line">                TemL2 = TemL2-&gt;Next;</span><br><span class="line">                Tem-&gt;Next = NewList;</span><br><span class="line">                Tem = Tem-&gt;Next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                TemL1 = TemL1-&gt;Next;</span><br><span class="line">                TemL2 = TemL2-&gt;Next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>( TemL1 != <span class="literal">NULL</span> &amp;&amp; (TemL1-&gt;Pow != <span class="number">0</span> || TemL1-&gt;Coef != <span class="number">0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        List NewList = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">        NewList-&gt;Coef = TemL1-&gt;Coef;</span><br><span class="line">        NewList-&gt;Pow = TemL1-&gt;Pow;</span><br><span class="line">        NewList-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">        TemL1 = TemL1-&gt;Next;</span><br><span class="line">        Tem-&gt;Next = NewList;</span><br><span class="line">        Tem = Tem-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>( TemL2 != <span class="literal">NULL</span> &amp;&amp; (TemL2-&gt;Pow != <span class="number">0</span> || TemL2-&gt;Coef != <span class="number">0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        List NewList = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">        NewList-&gt;Coef = TemL2-&gt;Coef;</span><br><span class="line">        NewList-&gt;Pow = TemL2-&gt;Pow;</span><br><span class="line">        NewList-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">        TemL2 = TemL2-&gt;Next;</span><br><span class="line">        Tem-&gt;Next = NewList;</span><br><span class="line">        Tem = Tem-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( L-&gt;Next == <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        List NewList = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">        NewList-&gt;Coef = NewList-&gt;Pow = <span class="number">0</span>;</span><br><span class="line">        NewList-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">        L-&gt;Next = NewList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteList</span><span class="params">( List L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List Tem = L-&gt;Next;</span><br><span class="line">    <span class="keyword">while</span>( Tem != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;Next = Tem-&gt;Next;</span><br><span class="line">        <span class="built_in">free</span>(Tem);</span><br><span class="line">        Tem = L-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">MultipleList</span><span class="params">( List L1,List L2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">    L-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    List InitialList = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">    InitialList-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    InitialList-&gt;Coef = InitialList-&gt;Pow = <span class="number">0</span>;</span><br><span class="line">    L-&gt;Next = InitialList;</span><br><span class="line">    List Tem = L;</span><br><span class="line">    List TemL1 = L1-&gt;Next;</span><br><span class="line">    List SubL = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">    SubL-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    List TemSubL = SubL;</span><br><span class="line">    <span class="keyword">while</span>( TemL1 != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        List TemL2 = L2-&gt;Next;</span><br><span class="line">        <span class="keyword">while</span>( TemL1-&gt;Coef != <span class="number">0</span> &amp;&amp; TemL2 != <span class="literal">NULL</span> &amp;&amp; TemL2-&gt;Coef != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            List NewList = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">            NewList-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">            NewList-&gt;Pow = TemL1-&gt;Pow + TemL2-&gt;Pow;</span><br><span class="line">            NewList-&gt;Coef = TemL1-&gt;Coef * TemL2-&gt;Coef;</span><br><span class="line">            TemSubL-&gt;Next = NewList;</span><br><span class="line">            TemSubL = TemSubL-&gt;Next;</span><br><span class="line">            TemL2 = TemL2-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">        L = <span class="built_in">AddList</span>( Tem, SubL );</span><br><span class="line">        <span class="built_in">DeleteList</span>(Tem);</span><br><span class="line">        <span class="built_in">free</span>(Tem);</span><br><span class="line">        Tem = L;</span><br><span class="line">        <span class="built_in">DeleteList</span>(SubL);</span><br><span class="line">        TemSubL = SubL;</span><br><span class="line">        TemL1 = TemL1-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L1 = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">    L1-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    List L2 = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">    L2-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//List AddL = (List)malloc(sizeof(struct LNode));</span></span><br><span class="line">    <span class="comment">//List MulL = (List)malloc(sizeof(struct LNode));</span></span><br><span class="line">    L1 = <span class="built_in">CreateList</span>( L1 );</span><br><span class="line">    L2 = <span class="built_in">CreateList</span>( L2 );</span><br><span class="line">    List AddL = <span class="built_in">AddList</span>( L1,L2 );</span><br><span class="line">    List MulL = <span class="built_in">MultipleList</span>( L1,L2 );</span><br><span class="line">    List TemAddL = AddL-&gt;Next;</span><br><span class="line">    List TemMulL = MulL-&gt;Next;</span><br><span class="line">    cout &lt;&lt; TemMulL-&gt;Coef &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; TemMulL-&gt;Pow;</span><br><span class="line">    TemMulL = TemMulL-&gt;Next;</span><br><span class="line">    <span class="keyword">while</span>( TemMulL != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; TemMulL-&gt;Coef &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; TemMulL-&gt;Pow;</span><br><span class="line">        TemMulL = TemMulL-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; TemAddL-&gt;Coef &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; TemAddL-&gt;Pow;</span><br><span class="line">    TemAddL = TemAddL-&gt;Next;</span><br><span class="line">    <span class="keyword">while</span>( TemAddL != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; TemAddL-&gt;Coef &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; TemAddL-&gt;Pow;</span><br><span class="line">        TemAddL = TemAddL-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">DeleteList</span>( L1 );</span><br><span class="line">    <span class="built_in">free</span>(L1);</span><br><span class="line">    <span class="built_in">DeleteList</span>( L2 );</span><br><span class="line">    <span class="built_in">free</span>(L2);</span><br><span class="line">    <span class="built_in">DeleteList</span>( AddL );</span><br><span class="line">    <span class="built_in">free</span>(AddL);</span><br><span class="line">    <span class="built_in">DeleteList</span>( MulL );</span><br><span class="line">    <span class="built_in">free</span>(MulL);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这一版的代码有几个<strong>心得</strong></li></ul><ol><li>使用了头结点；</li><li>构建头结点指针要做好初始化，包括头结点指向NULL指针，头结点不能赋值；</li><li>在建立链表的循环时，要注意先将框架搭好。</li></ol><h1 id="编程题04——Reversing-Linked-List"><a href="#编程题04——Reversing-Linked-List" class="headerlink" title="编程题04——Reversing Linked List"></a>编程题04——Reversing Linked List</h1><p>Given a constant <em>K</em> and a singly linked list <em>L</em>, you are supposed to reverse the links of every <em>K</em> elements on <em>L</em>. For example, given <em>L</em> being 1→2→3→4→5→6, if <em>K</em>=3, then you must output 3→2→1→6→5→4; if <em>K</em>=4, you must output 4→3→2→1→5→6.</p><h3 id="Input-Specification-1"><a href="#Input-Specification-1" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains the address of the first node, a positive <em>N</em> (≤105) which is the total number of nodes, and a positive <em>K</em> (≤<em>N</em>) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1.</p><p>Then <em>N</em> lines follow, each describes a node in the format:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure><p>where <code>Address</code> is the position of the node, <code>Data</code> is an integer, and <code>Next</code> is the position of the next node.</p><h3 id="Output-Specification-1"><a href="#Output-Specification-1" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00100 6 4</span><br><span class="line">00000 4 99999</span><br><span class="line">00100 1 12309</span><br><span class="line">68237 6 -1</span><br><span class="line">33218 3 00000</span><br><span class="line">99999 5 68237</span><br><span class="line">12309 2 33218</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00000 4 33218</span><br><span class="line">33218 3 12309</span><br><span class="line">12309 2 00100</span><br><span class="line">00100 1 99999</span><br><span class="line">99999 5 68237</span><br><span class="line">68237 6 -1</span><br></pre></td></tr></table></figure><h3 id="答案-5"><a href="#答案-5" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxIndex 100000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Index;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    Index Address;</span><br><span class="line">    List Next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></span><br><span class="line">    List SList[MaxIndex];</span><br><span class="line">    <span class="keyword">int</span> Top;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IndiceNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    Index Next;</span><br><span class="line">&#125; Indice[MaxIndex];</span><br><span class="line"></span><br><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack S = (Stack)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct SNode));</span><br><span class="line">    S-&gt;Top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">( Stack S, List L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S-&gt;SList[++S-&gt;Top] = L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Pop</span><span class="params">( Stack S )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;SList[S-&gt;Top--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAddress</span><span class="params">( Index Address )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> WeiShu = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( Address/WeiShu != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        WeiShu *= <span class="number">10</span>;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( Address == <span class="number">0</span> )</span><br><span class="line">        cnt--;</span><br><span class="line">    <span class="keyword">while</span>( cnt &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; Address;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">( List L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( L-&gt;Next != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">PrintAddress</span>( L-&gt;Address );</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; L-&gt;Data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">PrintAddress</span>( L-&gt;Next-&gt;Address );</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        L = L-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PrintAddress</span>( L-&gt;Address );</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; L-&gt;Data &lt;&lt; <span class="string">&quot; -1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteList</span><span class="params">( List L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( L!=<span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        List Tmp = L;</span><br><span class="line">        L = L-&gt;Next;</span><br><span class="line">        <span class="built_in">free</span>(Tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Index Start;</span><br><span class="line">    <span class="keyword">int</span> N,SubN;</span><br><span class="line">    cin &gt;&gt; Start &gt;&gt; N &gt;&gt; SubN;</span><br><span class="line">    <span class="keyword">int</span> i = N;</span><br><span class="line">    <span class="keyword">while</span>( i &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        Index Order;</span><br><span class="line">        cin &gt;&gt; Order;</span><br><span class="line">        cin &gt;&gt; Indice[Order].Data &gt;&gt; Indice[Order].Next;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    List L = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">    L-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;Address = Start;</span><br><span class="line">    L-&gt;Data = Indice[Start].Data;</span><br><span class="line">    List TemList = L;</span><br><span class="line">    List StartList = <span class="literal">NULL</span>;</span><br><span class="line">    N = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( Indice[Start].Next != <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        Start = Indice[Start].Next;</span><br><span class="line">        List NewList = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">        NewList-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">        NewList-&gt;Address = Start;</span><br><span class="line">        NewList-&gt;Data = Indice[Start].Data;</span><br><span class="line">        TemList-&gt;Next = NewList;</span><br><span class="line">        TemList = TemList-&gt;Next;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line">    TemList = L;</span><br><span class="line">    Stack S = <span class="built_in">CreateStack</span>();</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( i % SubN == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            S-&gt;Top = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SubN;i++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Push</span>( S,TemList );</span><br><span class="line">                TemList = TemList-&gt;Next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SubN;i++ )</span><br><span class="line">            &#123;</span><br><span class="line">                List NewList = <span class="built_in">Pop</span>( S );</span><br><span class="line">                <span class="keyword">if</span>( StartList == <span class="literal">NULL</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    L = NewList;</span><br><span class="line">                    StartList = NewList;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    StartList-&gt;Next = NewList;</span><br><span class="line">                    StartList = StartList-&gt;Next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            StartList-&gt;Next = TemList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TemList = L;</span><br><span class="line">    <span class="built_in">PrintList</span>( TemList );</span><br><span class="line">    <span class="built_in">DeleteList</span>( TemList );</span><br><span class="line">    <span class="built_in">free</span>(S);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编程题05——线性结构4：Pop-Sequence"><a href="#编程题05——线性结构4：Pop-Sequence" class="headerlink" title="编程题05——线性结构4：Pop Sequence"></a>编程题05——线性结构4：Pop Sequence</h1><p>Given a stack which can keep <em>M</em> numbers at most. Push <em>N</em> numbers in the order of 1, 2, 3, …, <em>N</em> and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if <em>M</em> is 5 and <em>N</em> is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.</p><h3 id="Input-Specification-2"><a href="#Input-Specification-2" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): <em>M</em> (the maximum capacity of the stack), <em>N</em> (the length of push sequence), and <em>K</em> (the number of pop sequences to be checked). Then <em>K</em> lines follow, each contains a pop sequence of <em>N</em> numbers. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification-2"><a href="#Output-Specification-2" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not.</p><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 7 5</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">3 2 1 7 5 6 4</span><br><span class="line">7 6 5 4 3 2 1</span><br><span class="line">5 6 4 3 7 2 1</span><br><span class="line">1 7 6 5 4 3 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><h3 id="答案-6"><a href="#答案-6" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 1000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> Capacity;</span><br><span class="line">    <span class="keyword">int</span> Top;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">( <span class="keyword">int</span> M )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack S = (Stack)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct SNode));</span><br><span class="line">    S-&gt;Capacity = M;</span><br><span class="line">    S-&gt;Top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">( Stack S )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( S-&gt;Top == <span class="number">-1</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">( Stack S )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( S-&gt;Top == S-&gt;Capacity<span class="number">-1</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">( Stack S,ElementType Item )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S-&gt;Data[++S-&gt;Top] = Item;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">( Stack S )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;Data[S-&gt;Top--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RightIndice</span><span class="params">( ElementType Number[],Stack S,<span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Index = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Push</span>(S,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( S-&gt;Data[S-&gt;Top] == Number[Index] )</span><br><span class="line">        &#123;</span><br><span class="line">            ElementType Item = <span class="built_in">Pop</span>(S);</span><br><span class="line">            Index++;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>( <span class="built_in">IsFull</span>(S) )</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">Push</span>(S,i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">IsEmpty</span>(S) )</span><br><span class="line">    &#123;</span><br><span class="line">        ElementType Item = <span class="built_in">Pop</span>(S);</span><br><span class="line">        <span class="keyword">if</span>( Item != Number[Index++] )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitialStack</span><span class="params">( Stack S )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S-&gt;Top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M,N,K;</span><br><span class="line">    cin &gt;&gt; M &gt;&gt; N &gt;&gt; K;</span><br><span class="line">    Stack S = <span class="built_in">CreateStack</span>( M );</span><br><span class="line">    ElementType Number[N];</span><br><span class="line">    <span class="keyword">while</span>( K &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++ )</span><br><span class="line">            cin &gt;&gt; Number[i];</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">RightIndice</span>( Number,S,N ) )</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">InitialStack</span>( S );</span><br><span class="line">        K--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础数据结构与算法（一）</title>
      <link href="/2021/06/11/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2021/06/11/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本文章主要介绍线性结构的基本操作，代码来自浙大慕课。</p><span id="more"></span><h1 id="第一部分-线性结构"><a href="#第一部分-线性结构" class="headerlink" title="第一部分 线性结构"></a>第一部分 线性结构</h1><p><strong>线性结构主要包括线性表、堆栈和队列，基本操作有建立初始结构，插入、删除、判断是否为空或满的，不止线性结构如此，一般数据结构均是以上几种基本操作。</strong></p><h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><p>线性结构分为顺序存储和链表两种模式。</p><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>顺序存储即开辟一块固定空间，大小固定，所有操作均在这块空间上进行。</p><ul><li>开辟初始空间</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize Max</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> Cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">InitialList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L = (List)<span class="built_in">malloc</span>( <span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode) );</span><br><span class="line">    L-&gt;Cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断是否为空/为满</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">( List L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( L-&gt;Cnt == MaxSize )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">( List L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( L-&gt;Cnt == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">( List L, ElementType E )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">IsFull</span>( L ) )</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Full&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        L-&gt;Data[L-&gt;Cnt++] = E;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li>链表初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    List Next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">InitialList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//- 创建头结点的方法</span></span><br><span class="line">    List L = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">    L-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">( List L,ElementType Item )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List Temp = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">    Temp-&gt;Data = Item;</span><br><span class="line">    Temp-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;Next = Temp;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p>堆栈指满足先进后出原则的一个线性存储结构。</p><h3 id="顺序存储的堆栈"><a href="#顺序存储的堆栈" class="headerlink" title="顺序存储的堆栈"></a>顺序存储的堆栈</h3><ul><li>初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> Top;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack <span class="title">InitialStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack S = (Stack)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct SNode));</span><br><span class="line">    S-&gt;Top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断堆栈是否为满/为空</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">( Stack S )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( S-&gt;Top &lt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">( Stack S )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( S-&gt;Top == MaxSize<span class="number">-1</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">( Stack S,ElementType Item )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">IsFull</span>( S ) )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Full&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        S-&gt;Data[++S-&gt;Top] = Item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">Delete</span><span class="params">( Stack S )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">IsEmpty</span>( S ) )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;Data[S-&gt;Top--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆栈的链表存储结构（头结点结构）"><a href="#堆栈的链表存储结构（头结点结构）" class="headerlink" title="堆栈的链表存储结构（头结点结构）"></a>堆栈的链表存储结构（头结点结构）</h3><ul><li>初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    Stack Next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack <span class="title">InitialStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack S = (Stack)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>( struct SNode ));</span><br><span class="line">    S-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">( Stack S, ElementType Item )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack ItemP = (Stack)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct SNode));</span><br><span class="line">    ItemP-&gt;Data = Item;</span><br><span class="line">    ItemP-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    Stack Tmp;</span><br><span class="line">    Tmp = S-&gt;Next;</span><br><span class="line">    S-&gt;Next = ItemP;</span><br><span class="line">    ItemP-&gt;Next = Tmp;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">Delete</span><span class="params">( Stack S )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( S-&gt;Next == <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack Tmp = S-&gt;Next;</span><br><span class="line">    S-&gt;Next = Tmp-&gt;Next;</span><br><span class="line">    ElementType Item = Tmp-&gt;Data;</span><br><span class="line">    <span class="built_in">free</span>( Tmp );</span><br><span class="line">    <span class="keyword">return</span> Item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="顺序存储队列"><a href="#顺序存储队列" class="headerlink" title="顺序存储队列"></a>顺序存储队列</h3><ul><li>初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> Front;</span><br><span class="line">    <span class="keyword">int</span> Rear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//- 采用循环队列的方法，</span></span><br><span class="line"><span class="function">Queue <span class="title">InitialQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue Q = (Queue)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct QNode));</span><br><span class="line">    Q-&gt;Front = Q-&gt;Rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断为空/为满</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">( Queue Q )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Q-&gt;Front == Q-&gt;Rear )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">( Queue Q )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( (Q-&gt;Rear+<span class="number">1</span>)%MaxSize==Q-&gt;Front )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">( Queue Q, ElementType Item )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">IsFull</span>( Q ) )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Full&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Q-&gt;Rear = ( Q-&gt;Rear + <span class="number">1</span> )%MaxSize;</span><br><span class="line">        Q-&gt;Data[Q-&gt;Rear] = Item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Queue <span class="title">Delete</span><span class="params">( Queue Q )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType Item;</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">IsEmpty</span>( Q ) )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Q-&gt;Front = ( Q-&gt;Front + <span class="number">1</span> )%MaxSize;</span><br><span class="line">        Item = Q-&gt;Data[Q-&gt;Front];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表存储队列"><a href="#链表存储队列" class="headerlink" title="链表存储队列"></a>链表存储队列</h3><ul><li>初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    Queue Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeadQNode</span> *<span class="title">HeadQueue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeadQNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Queue Front;</span><br><span class="line">    Queue Rear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">HeadQueue <span class="title">Initial</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HeadQueue HQ = (HeadQueue)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct HeadQNode));</span><br><span class="line">    HQ-&gt;Front = HQ-&gt;Rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> HQ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">( HeadQueue HQ, ElementType Item )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue Q = (Queue)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct QNode));</span><br><span class="line">    Q-&gt;Data = Item;</span><br><span class="line">    Q-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>( HQ-&gt;Front == <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        HQ-&gt;Front = Q;</span><br><span class="line">        HQ-&gt;Rear = Q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Queue RearQ = HQ-&gt;Rear;</span><br><span class="line">        RearQ-&gt;Next = Q;</span><br><span class="line">        HQ-&gt;Rear = Q;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">Delete</span><span class="params">( HeadQueue HQ )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( HQ-&gt;Front == <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( HQ-&gt;Front == HQ-&gt;Rear )</span><br><span class="line">    &#123;</span><br><span class="line">        ElementType Item = HQ-&gt;Front-&gt;Data;</span><br><span class="line">        <span class="built_in">free</span>( HQ-&gt;Front );</span><br><span class="line">        HQ-&gt;Front = HQ-&gt;Rear = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> Item;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue Q = HQ-&gt;Front;</span><br><span class="line">    HQ-&gt;Front = Q-&gt;Next;</span><br><span class="line">    ElementType Item = Q-&gt;Data;</span><br><span class="line">    <span class="built_in">free</span>(Q);</span><br><span class="line">    <span class="keyword">return</span> Item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown使用手册</title>
      <link href="/2021/06/06/MarkDown%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
      <url>/2021/06/06/MarkDown%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p>为MarkDown的使用提供一份说明文档，部分结果仅展示成果，可以复制到本地的<a href="https://www.typora.io/">Typora</a>查看源码。未来会持续更新</p><span id="more"></span><h3 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h3><p>标题一共包括六个级别，用#来表示，示意如下：<br># 标题1<br>## 标题2<br>### 标题3<br>#### 标题4<br>##### 标题5<br>###### 标题6<br>在MarkDown下分别表示如下：</p><h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><h2 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h2><h3 id="标题3"><a href="#标题3" class="headerlink" title="标题3"></a>标题3</h3><h4 id="标题4"><a href="#标题4" class="headerlink" title="标题4"></a>标题4</h4><h5 id="标题5"><a href="#标题5" class="headerlink" title="标题5"></a>标题5</h5><h6 id="标题6"><a href="#标题6" class="headerlink" title="标题6"></a>标题6</h6><p><strong>注：# 和字符中间空一格</strong></p><h3 id="二、列表"><a href="#二、列表" class="headerlink" title="二、列表"></a>二、列表</h3><p>列表的使用时-空一格加字符，如下：<br>- 文本1<br>- 文本2<br>- 文本3</p><ul><li>文本1</li><li>文本2</li><li>文本3</li></ul><p>如果加上有序序号的话</p><ol><li>文本1</li><li>文本2</li><li>文本3</li></ol><h3 id="三、插入链接和图片"><a href="#三、插入链接和图片" class="headerlink" title="三、插入链接和图片"></a>三、插入链接和图片</h3><h4 id="1-插入链接"><a href="#1-插入链接" class="headerlink" title="1.插入链接"></a>1.插入链接</h4><p>插入链接使用[显示文本]+(网址)的方式来显示链接，具体如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[百度](https://www.baidu.com/)</span><br></pre></td></tr></table></figure><p><a href="https://www.baidu.com/">百度</a></p><h4 id="2-插入图片"><a href="#2-插入图片" class="headerlink" title="2.插入图片"></a>2.插入图片</h4><p>出入图片和插入链接相似，使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://gitee.com/nighost/case/raw/master/Case.png)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/nighost/case/raw/master/Case.png" alt=""></p><p><strong>注：印象笔记的网址解析有问题，所以这里没有显示，但大体是这样用</strong></p><h3 id="四、引用"><a href="#四、引用" class="headerlink" title="四、引用"></a>四、引用</h3><p>引用只要使用> 文字即可</p><blockquote><p>人生得意须尽欢，莫使金樽空对月</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 人生得意须尽欢，莫使金樽空对月</span><br></pre></td></tr></table></figure><h3 id="五、粗体和斜体"><a href="#五、粗体和斜体" class="headerlink" title="五、粗体和斜体"></a>五、粗体和斜体</h3><p>斜体使用两个*，粗体使用四个*<br><em>斜体</em><br><strong>粗体</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*斜体*</span><br><span class="line">**粗体**</span><br></pre></td></tr></table></figure><h3 id="六、代码引用"><a href="#六、代码引用" class="headerlink" title="六、代码引用"></a>六、代码引用</h3><h4 id="1-单行代码"><a href="#1-单行代码" class="headerlink" title="1.单行代码"></a>1.单行代码</h4><p><code>hello world</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`hello world`</span><br></pre></td></tr></table></figure><h4 id="2-代码块"><a href="#2-代码块" class="headerlink" title="2.代码块"></a>2.代码块</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;isotream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、表格"><a href="#七、表格" class="headerlink" title="七、表格"></a>七、表格</h3><div class="table-container"><table><thead><tr><th>辛烷值</th><th>正庚烷比例</th><th>异辛烷比例</th><th>甲苯比例</th></tr></thead><tbody><tr><td>100</td><td>0</td><td>100</td><td>0</td></tr><tr><td>70</td><td>30</td><td>70</td><td>0</td></tr></tbody></table></div><h3 id="八、数学公式"><a href="#八、数学公式" class="headerlink" title="八、数学公式"></a>八、数学公式</h3><h4 id="1-行内公式和读行公式"><a href="#1-行内公式和读行公式" class="headerlink" title="1.行内公式和读行公式"></a>1.行内公式和读行公式</h4><ul><li>行内公式<br>一些内容$1+1=2$</li><li>独行公式<script type="math/tex; mode=display">1+1=2</script></li></ul><h4 id="2-上标、下标与组合"><a href="#2-上标、下标与组合" class="headerlink" title="2.上标、下标与组合"></a>2.上标、下标与组合</h4><ul><li><p>上标</p><script type="math/tex; mode=display">2^2=4</script></li><li><p>下标</p><script type="math/tex; mode=display">U_k=5</script></li><li><p>组合<br>使用{}来包含，避免歧义</p><script type="math/tex; mode=display">{16}_{8}O{2+}_{2}</script></li></ul><h4 id="3-汉字、字体与格式"><a href="#3-汉字、字体与格式" class="headerlink" title="3.汉字、字体与格式"></a>3.汉字、字体与格式</h4><ul><li>汉字<br>汉字的输入格式如下：<br>\$$V_{\mbox{初始}}$$<br><strong>注：印象笔记不支持数学公式中的汉字输入</strong></li><li>字体控制<br>不知道怎么做的控制，但加入displaystyle后字体明显变好看，如下：<br>$\displaystyle \frac{x+y}{y+z}$<br>$\frac{x+y}{y+z}$<br>再比如加和符号：<br>$\displaystyle \sum_X$<br>$\sum_X$<br>可以看到，加入字体控制，X的布局更合理</li><li>下划线控制<br>${x+y}$<br>$\underline {x+y}$</li><li>标签<br>$\tag{11}$<br><strong>注：印象笔记也不支持这个功能</strong></li><li>上大括号<br>$\overbrace{a+b+c+d}$</li><li>下大括号<br>$\underbrace {a+b+c+d}$</li><li><p>上位符号<br>写法如下<br>$stakcrel{上位符号}{基位符号}$<br>$\vec{x}\stackrel{\mathrm{def}}{=}{x_1,\dots,x_n}$<br>$\stackrel{\mathrm{de}}{=}$</p></li><li><p>公式字符加粗</p></li><li>$\boldsymbol{S}$</li></ul><h4 id="4-占位符"><a href="#4-占位符" class="headerlink" title="4.占位符"></a>4.占位符</h4><ul><li>两个quad空格<br>$x\qquad y$</li><li>一个quad空格<br>$x\quad y$</li><li>大空格(\加一个空格)<br>$x\ y$</li><li>中空格<br>$x\:y$</li><li>小空格<br>$x\,y$</li><li>没有空格<br>$xy$</li><li>紧贴<br>$x!y$</li></ul><h4 id="5-定位符与组合"><a href="#5-定位符与组合" class="headerlink" title="5.定位符与组合"></a>5.定位符与组合</h4><ul><li>括号<br>$(xy)$</li><li>中括号<br>$[xy]$</li><li>大括号<br>$\{xy\}$</li></ul><h4 id="6-四则运算"><a href="#6-四则运算" class="headerlink" title="6.四则运算"></a>6.四则运算</h4><ul><li>加法<br>$x+y=z$</li><li>减法<br>$x-y=z$</li><li>加减法<br>$x \pm y = z$</li><li>减加法<br>$x \mp y = z$</li><li>乘法<br>$x \times y = z$</li><li>点乘<br>$x \cdot y = z$</li><li>星乘<br>$x \ast y = z$</li><li>除法<br>$x \div y = z$</li><li>斜法<br>$x / y = z$</li><li>分式表示<br>$\displaystyle \frac{x}{y}$</li><li>分式表示<br>${x} \voer {y}$<br><strong>注：印象笔记不支持该显示</strong></li><li>绝对值<br>$|x|=|y|$</li></ul><h4 id="7-高级运算"><a href="#7-高级运算" class="headerlink" title="7.高级运算"></a>7.高级运算</h4><ul><li>平均数计算<br>$\displaystyle \overline{xyz}$</li><li>开二次方<br>$\sqrt x$</li><li>开方运算<br>$\sqrt[3]{xy}$</li><li>对数运算<br>$\log(x)$</li><li>极限运算<br>$\lim^{x\to\infty}_{y\to0}{\frac{x}{y}}$</li><li>字符控制极限运算<br>$\displaystyle \lim^{x\to\infty}_{y\to0}{\frac{x}{y}}$</li><li>求和运算<br>$\sum^{x\to\infty}_{y\to0}{\frac{x}{y}}$</li><li>字符控制求和运算<br>$\displaystyle \sum^{x\to\infty}_{y\to0}{\frac{x}{y}}$</li><li>积分运算<br>$\int^{\infty}_{0}xdx$</li><li>字符控制积分运算<br>$\displaystyle \int^{\infty}_{0}xdx$</li><li>微分运算<br>$\frac{\partial x}{\partial y}$</li><li>字符控制微分运算<br>$\displaystyle \frac{\partial x}{\partial y}$</li><li>矩阵表示<br>中括号表示</li></ul><script type="math/tex; mode=display">\left[\begin{matrix}   1 & 2 & 3\\   4 & 5 & 6\\   7 & 8 & 9\end{matrix}\right]</script><p>大括号表示</p><script type="math/tex; mode=display">\left\{\begin{matrix}   1 & 2 & 3\\   4 & 5 & 6\\   7 & 8 & 9'\end{matrix}\right\}</script><h5 id="8-逻辑运算"><a href="#8-逻辑运算" class="headerlink" title="8.逻辑运算"></a>8.逻辑运算</h5><ul><li>等于<br>$x+y=z$</li><li>大于<br>$x+y&gt;z$</li><li>小于<br>$x+y&lt;z$</li><li>大于等于<br>$x+y \geq z$</li><li>小于等于<br>$x+y \leq z$</li><li>不等于<br>$x+y \neq z$</li><li>不大于等于<br>$x+y \ngeq z$</li><li>不大于等于<br>$x+y \not\geq z$</li><li>不小于等于<br>$x+y \nleq z$</li><li>不小于等于<br>$x+y \not\leq z$</li><li>约等于<br>$x+y \approx z$</li><li>恒定等于<br>$x+y \equiv z$</li></ul><h5 id="9-集合运算"><a href="#9-集合运算" class="headerlink" title="9.集合运算"></a>9.集合运算</h5><ul><li>属于<br>$x \in y$</li><li>不属于<br>$x \notin y$</li><li>不属于<br>$x \not\in y$</li><li>子集<br>$x \subset y$<br>$x \supset y$</li><li>真子集<br>$x \subseteq y$<br>$x \supseteq y$</li><li>非真子集<br>$x \subsetneq y$<br>$x \supsetneq y$</li><li>非子集<br>$x \not\subset y$<br>$x \not\supset y$</li><li>并集<br>$x \cup y$</li><li>交集<br>$x \cap y$</li><li>差集<br>$x \setminus y$</li><li>同或<br>$x \bigodot y$</li><li>同与<br>$x \bigotimes y$</li><li>实数<br>$\mathbb{R}$</li><li>自然数<br>$\mathbb{Z}$</li><li>空集<br>$\emptyset$</li></ul><h5 id="10-数学符号"><a href="#10-数学符号" class="headerlink" title="10.数学符号"></a>10.数学符号</h5><ul><li><p>无穷<br>$\infty$</p></li><li><p>虚数<br>$\imath$<br>$\jmath$</p></li><li><p>数学符号<br>$\displaystyle \hat{a}$<br>$\check{a}$<br>$\breve{a}$<br>$\tilde{a}$<br>$\bar{a}$<br>$\acute{a}$<br>$\grave{a}$<br>$\mathring{a}$</p></li><li><p>矢量符号<br>$\displaystyle \vec{a}$</p></li><li><p>一阶导数符号<br>$\dot{a}$</p></li><li><p>二阶导数符号<br>$\ddot{a}$</p></li><li><p>上箭头<br>$\uparrow$<br>$\Uparrow$</p></li><li><p>下箭头<br>$\downarrow$<br>$\Downarrow$</p></li><li><p>左箭头<br>$\leftarrow$<br>$\Leftarrow$</p></li><li><p>右箭头<br>$\rightarrow$<br>$\Rightarrow$</p></li><li><p>低端对齐省略号<br>$1,2,\ldots,n$</p></li><li><p>中线对齐省略号<br>$\displaystyle X_1^2+X_2^2+X_3^2+\cdots+X_N^2$</p></li><li><p>竖直对齐省略号(矩阵使用)<br>$\vdots$</p></li><li><p>斜对齐省略号<br>$\ddots$</p></li><li><p>散度/梯度符号<br>$\nabla$</p></li><li><p>向下取整</p><p>$\lfloor$</p><p>$\rfloor$</p></li><li><p>向上取整</p><p>$\lceil$</p><p>$\rceil$</p></li></ul><h5 id="11-希腊字母"><a href="#11-希腊字母" class="headerlink" title="11.希腊字母"></a>11.希腊字母</h5><div class="table-container"><table><thead><tr><th>字母</th><th>实现</th><th>字母</th><th>实现</th></tr></thead><tbody><tr><td>A</td><td>A</td><td>$\alpha$</td><td>\alpha</td></tr><tr><td>B</td><td>B</td><td>$\beta$</td><td>\beta</td></tr><tr><td>$\Gamma$</td><td>\Gamma</td><td>$\gamma$</td><td>\gamma</td></tr><tr><td>$\Delta$</td><td>\Delta</td><td>$\delta$</td><td>\delta</td></tr><tr><td>E</td><td>E</td><td>$\epsilon$</td><td>\epsilon</td></tr><tr><td>Z</td><td>Z</td><td>$\zeta$</td><td>\zeta</td></tr><tr><td>H</td><td>H</td><td>$\eta$</td><td>\eta</td></tr><tr><td>$\Theta$</td><td>\Theta</td><td>$\theta$</td><td>\theta</td></tr><tr><td>I</td><td>I</td><td>$\iota$</td><td>\iota</td></tr><tr><td>K</td><td>K</td><td>$\kappa$</td><td>\kappa</td></tr><tr><td>$\Lambda$</td><td>\Lambda</td><td>$\lambda$</td><td>\lambda</td></tr><tr><td>M</td><td>M</td><td>$\mu$</td><td>\mu</td></tr><tr><td>N</td><td>N</td><td>$\nu$</td><td>\nu</td></tr><tr><td>$\Xi$</td><td>\Xi</td><td>$\xi$</td><td>\xi</td></tr><tr><td>O</td><td>$O$</td><td>$\omicron$</td><td>\omicron</td></tr><tr><td>$\Pi$</td><td>\Pi</td><td>$\pi$</td><td>\pi</td></tr><tr><td>$P$</td><td>P</td><td>$\rho$</td><td>\rho</td></tr><tr><td>$\Sigma$</td><td>\Sigma</td><td>$\sigma$</td><td>\sigma</td></tr><tr><td>T</td><td>T</td><td>$\tau$</td><td>\tau</td></tr><tr><td>$\Upsilon$</td><td>\Upsilon</td><td>$\upsilon$</td><td>\upsilon</td></tr><tr><td>$\Phi$</td><td>\Phi</td><td>$\phi$</td><td>\phi</td></tr><tr><td>$X$</td><td>X</td><td>$\chi$</td><td>\chi</td></tr><tr><td>$\Psi$</td><td>\Psi</td><td>$\psi$</td><td>\psi</td></tr><tr><td>$\Omega$</td><td>\Omega</td><td>$\omega$</td><td>\omega</td></tr></tbody></table></div><h5 id="12-多行数学公式"><a href="#12-多行数学公式" class="headerlink" title="12.多行数学公式"></a>12.多行数学公式</h5><script type="math/tex; mode=display">\begin{aligned}x &= v_0\cos\theta t \\y &= v_0\sin\theta t - \frac{1}{2}gt^2 \\y &= v_0\sin\theta t - \frac{1}{2}gt^2\end{aligned}</script><h3 id="九、流程图"><a href="#九、流程图" class="headerlink" title="九、流程图"></a>九、流程图</h3><p><strong>注：在印象笔记中流程图使用代码块功能，但在其他markdown中不用使用代码块</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[模块A] --&gt;|A1| B(模块B)</span><br><span class="line">B --&gt; C&#123;判断条件C&#125;</span><br><span class="line">C --&gt;|条件C1| D[模块D]</span><br><span class="line">C --&gt;|条件C2| E[模块E]</span><br><span class="line">C --&gt;|条件C3| F[模块F]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
