<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>基础数据结构与算法（二）</title>
      <link href="/2021/06/21/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2021/06/21/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本文章主要介绍树的基本操作，代码来自浙大慕课。</p><span id="more"></span><h1 id="树的存储方式"><a href="#树的存储方式" class="headerlink" title="树的存储方式"></a>树的存储方式</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 链表方式</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    Tree Left;</span><br><span class="line">    Tree Right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 顺序存储方式</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span> *<span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> Left;</span><br><span class="line">    <span class="keyword">int</span> Right;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 静态链表方式</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    <span class="keyword">int</span> Left;</span><br><span class="line">    <span class="keyword">int</span> Right;</span><br><span class="line">&#125; T1[MaxSize],T2[MaxSize];</span><br></pre></td></tr></table></figure><h1 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 递归方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">( Tree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( T )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; T-&gt;Data &lt;&lt; endl; <span class="comment">//- 先序遍历 </span></span><br><span class="line">        <span class="built_in">PreOrderTraversal</span>( T-&gt;Left );</span><br><span class="line">        cout &lt;&lt; T-&gt;Data &lt;&lt; endl; <span class="comment">//- 中序遍历</span></span><br><span class="line">        <span class="built_in">PreOrderTraversal</span>( T-&gt;Right );</span><br><span class="line">        cout &lt;&lt; T-&gt;Data &lt;&lt; endl; <span class="comment">//- 后序遍历</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 非递归方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraversal</span><span class="params">( Tree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree Tmp = T;</span><br><span class="line">    Stack S = <span class="built_in">CreateStack</span>();</span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">IsEmpty</span>(S) || Tmp != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>( Tmp!=<span class="literal">NULL</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; Tmp-&gt;Data &lt;&lt; endl; <span class="comment">//- 先序遍历</span></span><br><span class="line">            <span class="built_in">Push</span>( S,Tmp );</span><br><span class="line">            Tmp = Tmp-&gt;Left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( !<span class="built_in">IsEmpty</span>( S ) )</span><br><span class="line">        &#123;</span><br><span class="line">            Tmp = <span class="built_in">Pop</span>(S);</span><br><span class="line">            cout &lt;&lt; Tmp-&gt;Data &lt;&lt; endl; <span class="comment">//- 中序遍历</span></span><br><span class="line">            Tmp = Tmp-&gt;Right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="二叉树的层次遍历"><a href="#二叉树的层次遍历" class="headerlink" title="二叉树的层次遍历"></a>二叉树的层次遍历</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非递归方式</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraversal</span><span class="params">( Tree T )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Tree Tmp = T;</span><br><span class="line">    Queue Q = <span class="built_in">CreateQueue</span>();</span><br><span class="line">    <span class="built_in">AddQ</span>(Q,Tmp);</span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">IsEmpty</span>(Q) )</span><br><span class="line">    &#123;</span><br><span class="line">        Tmp = <span class="built_in">DeleteQ</span>( Q );</span><br><span class="line">        cout &lt;&lt; Tmp-&gt;Data &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span>( Tmp-&gt;Left != <span class="literal">NULL</span> ) <span class="built_in">AddQ</span>(Q,Tmp-&gt;Left);</span><br><span class="line">        <span class="keyword">if</span>( Tmp-&gt;Right != <span class="literal">NULL</span> ) <span class="built_in">AddQ</span>(Q,Tmp-&gt;Right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="输出二叉树的所有叶结点"><a href="#输出二叉树的所有叶结点" class="headerlink" title="输出二叉树的所有叶结点"></a>输出二叉树的所有叶结点</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintLeaves</span><span class="params">( BinTree BST )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(BST)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( BST-&gt;Left == <span class="literal">NULL</span> &amp;&amp; BST-&gt;Right == <span class="literal">NULL</span> )</span><br><span class="line">            cout &lt;&lt; BST-&gt;Data &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">PrintLeaves</span>( BST-&gt;Left );</span><br><span class="line">        <span class="built_in">PrintLeaves</span>( BST-&gt;Right );</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="输出二叉树的高度"><a href="#输出二叉树的高度" class="headerlink" title="输出二叉树的高度"></a>输出二叉树的高度</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetHeight</span><span class="params">( BinTree BST )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( BST )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> LeftHeight,RightHeight;</span><br><span class="line">        LeftHeight = <span class="built_in">GetHeight</span>( BST-&gt;Left );</span><br><span class="line">        RightHeight = <span class="built_in">GetHeight</span>( BST-&gt;Right );</span><br><span class="line">        <span class="keyword">int</span> MaxHeight = LeftHeight &gt; RightHeight ? LeftHeight : RightHeight;</span><br><span class="line">        MaxHeight++;</span><br><span class="line">        <span class="keyword">return</span> MaxHeight;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="根据先序和中序序列，确定二叉树"><a href="#根据先序和中序序列，确定二叉树" class="headerlink" title="根据先序和中序序列，确定二叉树"></a>根据先序和中序序列，确定二叉树</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BinTree <span class="title">PreInBulidTree</span><span class="params">( ElementType Pre[],ElementType In[],<span class="keyword">int</span> PreStart,<span class="keyword">int</span> PreEnd,<span class="keyword">int</span> InStart,<span class="keyword">int</span> InEnd )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( PreStart &gt; PreEnd || InStart &gt; InEnd )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">int</span> PreRootItem = Pre[PreStart];</span><br><span class="line">    <span class="keyword">int</span> InRootIndex;</span><br><span class="line">    <span class="keyword">int</span> IndexNum = PreEnd - PreStart + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>;i &lt; IndexNum;i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( In[i] == PreRootItem )</span><br><span class="line">        &#123;</span><br><span class="line">            InRootIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> LeftNum = InRootIndex - InStart;</span><br><span class="line">    <span class="keyword">int</span> RightNum = InEnd - InRootIndex;</span><br><span class="line">    BinTree BST = (BinTree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct TNode));</span><br><span class="line">    BST-&gt;Data = PreRootItem;</span><br><span class="line">    BST-&gt;Left = <span class="built_in">PreInBuildTree</span>( Pre,In,PreStart+<span class="number">1</span>,PreStart+LeftNum,InStart,InRootIndex<span class="number">-1</span> );</span><br><span class="line">    BST-&gt;Right = <span class="built_in">PreInBuildTree</span>( Pre,In,PreStart+LeftNum+<span class="number">1</span>,PreEnd,InRootIndex+<span class="number">1</span>,InEnd );</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>后续更新AVL、堆和并查集</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础数据结构与算法习题（二）</title>
      <link href="/2021/06/21/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/"/>
      <url>/2021/06/21/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98%EF%BC%88%E4%BA%8C%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>PTA上第三章的习题。</p><span id="more"></span><h1 id="编程题06——树的同构"><a href="#编程题06——树的同构" class="headerlink" title="编程题06——树的同构"></a>编程题06——树的同构</h1><p>给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。例如图1给出的两棵树就是同构的，因为我们把其中一棵树的结点A、B、G的左右孩子互换后，就得到另外一棵树。而图2就不是同构的。</p><p><img src="https://gitee.com/nighost/image-base-of-blog/raw/master/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98/%E7%BC%96%E7%A8%8B%E9%A2%9806%E5%9B%BE1.png" alt=""></p><center>图1</center><p><img src="https://gitee.com/nighost/image-base-of-blog/raw/master/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98/%E7%BC%96%E7%A8%8B%E9%A2%9806%E5%9B%BE2.png" alt=""></p><center>图2</center><p>现给定两棵树，请你判断它们是否是同构的。</p><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入给出2棵二叉树树的信息。对于每棵树，首先在一行中给出一个非负整数<em>N</em> (≤10)，即该树的结点数（此时假设结点从0到<em>N</em>−1编号）；随后<em>N</em>行，第<em>i</em>行对应编号第<em>i</em>个结点，给出该结点中存储的1个英文大写字母、其左孩子结点的编号、右孩子结点的编号。如果孩子结点为空，则在相应位置上给出“-”。给出的数据间用一个空格分隔。注意：题目保证每个结点中存储的字母是不同的。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>如果两棵树是同构的，输出“Yes”，否则输出“No”。</p><h3 id="输入样例1（对应图1）："><a href="#输入样例1（对应图1）：" class="headerlink" title="输入样例1（对应图1）："></a>输入样例1（对应图1）：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">A 1 2</span><br><span class="line">B 3 4</span><br><span class="line">C 5 -</span><br><span class="line">D - -</span><br><span class="line">E 6 -</span><br><span class="line">G 7 -</span><br><span class="line">F - -</span><br><span class="line">H - -</span><br><span class="line">8</span><br><span class="line">G - 4</span><br><span class="line">B 7 6</span><br><span class="line">F - -</span><br><span class="line">A 5 1</span><br><span class="line">H - -</span><br><span class="line">C 0 -</span><br><span class="line">D - -</span><br><span class="line">E 2 -</span><br></pre></td></tr></table></figure><h3 id="输出样例1"><a href="#输出样例1" class="headerlink" title="输出样例1:"></a>输出样例1:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Yes</span><br></pre></td></tr></table></figure><h3 id="输入样例2（对应图2）："><a href="#输入样例2（对应图2）：" class="headerlink" title="输入样例2（对应图2）："></a>输入样例2（对应图2）：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">B 5 7</span><br><span class="line">F - -</span><br><span class="line">A 0 3</span><br><span class="line">C 6 -</span><br><span class="line">H - -</span><br><span class="line">D - -</span><br><span class="line">G 4 -</span><br><span class="line">E 1 -</span><br><span class="line">8</span><br><span class="line">D 6 -</span><br><span class="line">B 5 -</span><br><span class="line">E - -</span><br><span class="line">H - -</span><br><span class="line">C 0 2</span><br><span class="line">G - 3</span><br><span class="line">F - -</span><br><span class="line">A 1 4</span><br></pre></td></tr></table></figure><h3 id="输出样例2"><a href="#输出样例2" class="headerlink" title="输出样例2:"></a>输出样例2:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No</span><br></pre></td></tr></table></figure><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> Left;</span><br><span class="line">    <span class="keyword">int</span> Right;</span><br><span class="line">    <span class="keyword">char</span> Letter;</span><br><span class="line">&#125; T1[MaxSize],T2[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreateTree</span><span class="params">( <span class="keyword">int</span> N,struct TNode T[] )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( N == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> Trigger[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> Item,Lef,Rig;</span><br><span class="line">        cin &gt;&gt; Item &gt;&gt; Lef &gt;&gt; Rig;</span><br><span class="line">        T[i].Letter = Item;</span><br><span class="line">        <span class="keyword">if</span>( Lef != <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            T[i].Left = Lef - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            Trigger[Lef-<span class="string">&#x27;0&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T[i].Left = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span>( Rig != <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            T[i].Right = Rig - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            Trigger[Rig-<span class="string">&#x27;0&#x27;</span>] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            T[i].Right = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Root;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( Trigger[i] == <span class="number">0</span> )</span><br><span class="line">            Root = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsIsomophic</span><span class="params">( <span class="keyword">int</span> Root1,<span class="keyword">int</span> Root2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Root1 == <span class="number">-1</span> &amp;&amp; Root2 == <span class="number">-1</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>( (Root1 != <span class="number">-1</span> &amp;&amp; Root2 == <span class="number">-1</span>) || (Root1 == <span class="number">-1</span> &amp;&amp; Root2 != <span class="number">-1</span>) )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( T1[Root1].Letter != T2[Root2].Letter )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>( T1[Root1].Left == <span class="number">-1</span> &amp;&amp; T2[Root2].Left == <span class="number">-1</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">IsIsomophic</span>( T1[Root1].Right,T2[Root2].Right );</span><br><span class="line">    <span class="keyword">if</span>( T1[Root1].Left != <span class="number">-1</span> &amp;&amp; T2[Root2].Left != <span class="number">-1</span> &amp;&amp; </span><br><span class="line">       T1[T1[Root1].Left].Letter == T2[T2[Root2].Left].Letter )</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">IsIsomophic</span>( T1[Root1].Left,T2[Root2].Left ) &amp;&amp; <span class="built_in">IsIsomophic</span>( T1[Root1].Right,T2[Root2].Right );</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">IsIsomophic</span>( T1[Root1].Left,T2[Root2].Right ) &amp;&amp; <span class="built_in">IsIsomophic</span>( T1[Root1].Right,T2[Root2].Left );</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">int</span> Root1 = <span class="built_in">CreateTree</span>( N,T1 );</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">int</span> Root2 = <span class="built_in">CreateTree</span>( N,T2 );</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">IsIsomophic</span>( Root1,Root2 ) )</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Yes&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;No&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编程题07——List-Leaves"><a href="#编程题07——List-Leaves" class="headerlink" title="编程题07——List Leaves"></a>编程题07——List Leaves</h1><p>Given a tree, you are supposed to list all the leaves in the order of top down, and left to right.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line gives a positive integer <em>N</em> (≤10) which is the total number of nodes in the tree — and hence the nodes are numbered from 0 to <em>N</em>−1. Then <em>N</em> lines follow, each corresponds to a node, and gives the indices of the left and right children of the node. If the child does not exist, a “-“ will be put at the position. Any pair of children are separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print in one line all the leaves’ indices in the order of top down, and left to right. There must be exactly one space between any adjacent numbers, and no extra space at the end of the line.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">8</span><br><span class="line">1 -</span><br><span class="line">- -</span><br><span class="line">0 -</span><br><span class="line">2 7</span><br><span class="line">- -</span><br><span class="line">- -</span><br><span class="line">5 -</span><br><span class="line">4 6</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">4 1 5</span><br></pre></td></tr></table></figure><h3 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    <span class="keyword">int</span> Left;</span><br><span class="line">    <span class="keyword">int</span> Right;</span><br><span class="line">&#125; T[MaxSize];</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> <span class="title">Data</span>[<span class="title">MaxSize</span>];</span></span><br><span class="line">    <span class="keyword">int</span> Front,Rear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">( Queue Q )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Q-&gt;Front == Q-&gt;Rear )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">AddQ</span><span class="params">( Queue Q,<span class="keyword">int</span> Root )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q-&gt;Rear = (Q-&gt;Rear+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    Q-&gt;Data[Q-&gt;Rear] = T[Root];</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">struct TNode <span class="title">DeleteQ</span><span class="params">( Queue Q )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q-&gt;Front = (Q-&gt;Front+<span class="number">1</span>)%MaxSize;</span><br><span class="line">    <span class="keyword">return</span> Q-&gt;Data[Q-&gt;Front];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CreateTree</span><span class="params">( <span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Trigger[N] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">char</span> left,right;</span><br><span class="line">        cin &gt;&gt; left &gt;&gt; right;</span><br><span class="line">        T[i].Data = i;</span><br><span class="line">        <span class="keyword">if</span>( left != <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            T[i].Left = left - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            Trigger[T[i].Left] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            T[i].Left = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>( right != <span class="string">&#x27;-&#x27;</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            T[i].Right = right - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            Trigger[T[i].Right] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            T[i].Right = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> Root;</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( Trigger[i] == <span class="number">0</span> )</span><br><span class="line">            Root = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Root;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">int</span> Root = <span class="built_in">CreateTree</span>( N );</span><br><span class="line">    <span class="keyword">int</span> Leaves[N];</span><br><span class="line">    <span class="keyword">int</span> LeavesCnt = <span class="number">0</span>;</span><br><span class="line">    Queue Q = (Queue)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct QNode));</span><br><span class="line">    Q-&gt;Front = Q-&gt;Rear = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">AddQ</span>( Q, Root );</span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">IsEmpty</span>(Q) )</span><br><span class="line">    &#123;</span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> <span class="title">Tmp</span> =</span> <span class="built_in">DeleteQ</span>( Q );</span><br><span class="line">       <span class="keyword">if</span>( Tmp.Left == <span class="number">-1</span> &amp;&amp; Tmp.Right == <span class="number">-1</span> )</span><br><span class="line">           Leaves[LeavesCnt++] = Tmp.Data;</span><br><span class="line">        <span class="keyword">if</span>( Tmp.Left != <span class="number">-1</span> ) <span class="built_in">AddQ</span>( Q,Tmp.Left );</span><br><span class="line">        <span class="keyword">if</span>( Tmp.Right != <span class="number">-1</span> ) <span class="built_in">AddQ</span>( Q,Tmp.Right );</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; Leaves[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;LeavesCnt;i++ )</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; Leaves[i];</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编程题08——Tree-Traversals-Again"><a href="#编程题08——Tree-Traversals-Again" class="headerlink" title="编程题08——Tree Traversals Again"></a>编程题08——Tree Traversals Again</h1><p>An inorder binary tree traversal can be implemented in a non-recursive way with a stack. For example, suppose that when a 6-node binary tree (with the keys numbered from 1 to 6) is traversed, the stack operations are: push(1); push(2); push(3); pop(); pop(); push(4); pop(); pop(); push(5); push(6); pop(); pop(). Then a unique binary tree (shown in Figure 1) can be generated from this sequence of operations. Your task is to give the postorder traversal sequence of this tree.</p><p><img src="https://gitee.com/nighost/image-base-of-blog/raw/master/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98/%E7%BC%96%E7%A8%8B%E9%A2%9808%E5%9B%BE1.png" alt=""></p><h3 id="Input-Specification-1"><a href="#Input-Specification-1" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains a positive integer <em>N</em> (≤30) which is the total number of nodes in a tree (and hence the nodes are numbered from 1 to <em>N</em>). Then 2<em>N</em> lines follow, each describes a stack operation in the format: “Push X” where X is the index of the node being pushed onto the stack; or “Pop” meaning to pop one node from the stack.</p><h3 id="Output-Specification-1"><a href="#Output-Specification-1" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, print the postorder traversal sequence of the corresponding tree in one line. A solution is guaranteed to exist. All the numbers must be separated by exactly one space, and there must be no extra space at the end of the line.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">Push 1</span><br><span class="line">Push 2</span><br><span class="line">Push 3</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Push 4</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br><span class="line">Push 5</span><br><span class="line">Push 6</span><br><span class="line">Pop</span><br><span class="line">Pop</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3 4 2 6 5 1</span><br></pre></td></tr></table></figure><h3 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&quot;string.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">TNode</span> *<span class="title">Tree</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">TNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    Tree Left;</span><br><span class="line">    Tree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Tree <span class="title">CreateTree</span><span class="params">( <span class="keyword">int</span>&amp; N )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( N == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    string Str;</span><br><span class="line">    cin &gt;&gt; Str;</span><br><span class="line">    N--;</span><br><span class="line">    <span class="keyword">if</span>( Str == <span class="string">&quot;Push&quot;</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        Tree T = (Tree)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct TNode));</span><br><span class="line">        cin &gt;&gt; T-&gt;Data;</span><br><span class="line">        T-&gt;Left = <span class="built_in">CreateTree</span>( N );</span><br><span class="line">        T-&gt;Right = <span class="built_in">CreateTree</span>( N );</span><br><span class="line">        <span class="keyword">return</span> T;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraversal</span><span class="params">( Tree T,<span class="keyword">int</span> Node[],<span class="keyword">int</span>&amp; cnt )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( T != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">PostOrderTraversal</span>( T-&gt;Left,Node,cnt );</span><br><span class="line">        <span class="built_in">PostOrderTraversal</span>( T-&gt;Right,Node,cnt );</span><br><span class="line">        Node[cnt++] = T-&gt;Data;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin &gt;&gt;N;</span><br><span class="line">    <span class="keyword">int</span> RealN = N;</span><br><span class="line">    N *= <span class="number">2</span>;</span><br><span class="line">    Tree T = <span class="built_in">CreateTree</span>( N );</span><br><span class="line">    <span class="comment">//cout &lt;&lt; T-&gt;Left-&gt;Left-&gt;Data &lt;&lt; endl;</span></span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> Node[RealN];</span><br><span class="line">    <span class="built_in">PostOrderTraversal</span>( T,Node,cnt );</span><br><span class="line">    <span class="comment">//PostOrderTraversal(T);</span></span><br><span class="line">    cout &lt;&lt; Node[<span class="number">0</span>];</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;RealN;i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; Node[i];</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>注意N是引用传值，最后会递减成0，在建立树之前最好使用一个RealN来存储N。</li></ul><ul><li>下周更新AVL，平衡二叉树的编程作业</li></ul>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础数据结构与算法习题（一）</title>
      <link href="/2021/06/17/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2021/06/17/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%E4%B9%A0%E9%A2%98%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>PTA上第一章和第二章的习题。</p><span id="more"></span><h1 id="函数题01——二分查找"><a href="#函数题01——二分查找" class="headerlink" title="函数题01——二分查找"></a>函数题01——二分查找</h1><p>本题要求实现二分查找算法。</p><h3 id="函数接口定义："><a href="#函数接口定义：" class="headerlink" title="函数接口定义："></a>函数接口定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">BinarySearch</span><span class="params">( List L, ElementType X )</span></span>;</span><br></pre></td></tr></table></figure><p>其中<code>List</code>结构定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    Position Last; <span class="comment">/* 保存线性表中最后一个元素的位置 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><code>L</code>是用户传入的一个线性表，其中<code>ElementType</code>元素可以通过&gt;、==、&lt;进行比较，并且题目保证传入的数据是递增有序的。函数<code>BinarySearch</code>要查找<code>X</code>在<code>Data</code>中的位置，即数组下标（注意：元素从下标1开始存储）。找到则返回下标，否则返回一个特殊的失败标记<code>NotFound</code>。</p><h3 id="裁判测试程序样例："><a href="#裁判测试程序样例：" class="headerlink" title="裁判测试程序样例："></a>裁判测试程序样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NotFound 0</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Position;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> &#123;</span></span><br><span class="line">    ElementType Data[MAXSIZE];</span><br><span class="line">    Position Last; <span class="comment">/* 保存线性表中最后一个元素的位置 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">ReadInput</span><span class="params">()</span></span>; <span class="comment">/* 裁判实现，细节不表。元素从下标1开始存储 */</span></span><br><span class="line"><span class="function">Position <span class="title">BinarySearch</span><span class="params">( List L, ElementType X )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L;</span><br><span class="line">    ElementType X;</span><br><span class="line">    Position P;</span><br><span class="line"></span><br><span class="line">    L = <span class="built_in">ReadInput</span>();</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">    P = <span class="built_in">BinarySearch</span>( L, X );</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, P);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure><h3 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">12 31 55 89 101</span><br><span class="line">31</span><br></pre></td></tr></table></figure><h3 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2</span><br></pre></td></tr></table></figure><h3 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">26 78 233</span><br><span class="line">31</span><br></pre></td></tr></table></figure><h3 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="答案"><a href="#答案" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Position <span class="title">BinarySearch</span><span class="params">( List L, ElementType X )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Start = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> End = L-&gt;Last;</span><br><span class="line">    <span class="comment">//int Middle = ( Start + End )/2;</span></span><br><span class="line">    <span class="keyword">while</span>( Start &lt;= End )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> Middle = ( Start + End )/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>( L-&gt;Data[Middle] == X )</span><br><span class="line">            <span class="keyword">return</span> Middle;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( L-&gt;Data[Middle] &lt; X )</span><br><span class="line">            Start = Middle + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            End = Middle - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> NotFound;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="函数题02——线性结构1：两个有序链表序列的合并"><a href="#函数题02——线性结构1：两个有序链表序列的合并" class="headerlink" title="函数题02——线性结构1：两个有序链表序列的合并"></a>函数题02——线性结构1：两个有序链表序列的合并</h1><p>本题要求实现一个函数，将两个链表表示的递增整数序列合并为一个非递减的整数序列。</p><h3 id="函数接口定义：-1"><a href="#函数接口定义：-1" class="headerlink" title="函数接口定义："></a>函数接口定义：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">Merge</span><span class="params">( List L1, List L2 )</span></span>;</span><br></pre></td></tr></table></figure><p>其中<code>List</code>结构定义如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ElementType Data; <span class="comment">/* 存储结点数据 */</span></span><br><span class="line">    PtrToNode   Next; <span class="comment">/* 指向下一个结点的指针 */</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List; <span class="comment">/* 定义单链表类型 */</span></span><br></pre></td></tr></table></figure><p><code>L1</code>和<code>L2</code>是给定的带头结点的单链表，其结点存储的数据是递增有序的；函数<code>Merge</code>要将<code>L1</code>和<code>L2</code>合并为一个非递减的整数序列。应直接使用原序列中的结点，返回归并后的带头结点的链表头指针。</p><h3 id="裁判测试程序样例：-1"><a href="#裁判测试程序样例：-1" class="headerlink" title="裁判测试程序样例："></a>裁判测试程序样例：</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PtrToNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    PtrToNode   Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> PtrToNode List;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Read</span><span class="params">()</span></span>; <span class="comment">/* 细节在此不表 */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Print</span><span class="params">( List L )</span></span>; <span class="comment">/* 细节在此不表；空链表将输出NULL */</span></span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Merge</span><span class="params">( List L1, List L2 )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L1, L2, L;</span><br><span class="line">    L1 = <span class="built_in">Read</span>();</span><br><span class="line">    L2 = <span class="built_in">Read</span>();</span><br><span class="line">    L = <span class="built_in">Merge</span>(L1, L2);</span><br><span class="line">    <span class="built_in">Print</span>(L);</span><br><span class="line">    <span class="built_in">Print</span>(L1);</span><br><span class="line">    <span class="built_in">Print</span>(L2);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br></pre></td></tr></table></figure><h3 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3</span><br><span class="line">1 3 5</span><br><span class="line">5</span><br><span class="line">2 4 6 8 10</span><br></pre></td></tr></table></figure><h3 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 4 5 6 8 10 </span><br><span class="line">NULL</span><br><span class="line">NULL</span><br></pre></td></tr></table></figure><h3 id="答案-1"><a href="#答案-1" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">Merge</span><span class="params">( List L1, List L2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct Node));</span><br><span class="line">    List TempL = L;</span><br><span class="line">    L-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>( L1-&gt;Next != <span class="literal">NULL</span> &amp;&amp; L2-&gt;Next != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( L1-&gt;Next-&gt;Data &lt;= L2-&gt;Next-&gt;Data )</span><br><span class="line">        &#123;</span><br><span class="line">            TempL-&gt;Next = L1-&gt;Next;</span><br><span class="line">            TempL = TempL-&gt;Next;</span><br><span class="line">            L1-&gt;Next = TempL-&gt;Next;</span><br><span class="line">            TempL-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            TempL-&gt;Next = L2-&gt;Next;</span><br><span class="line">            TempL = TempL-&gt;Next;</span><br><span class="line">            L2-&gt;Next = TempL-&gt;Next;</span><br><span class="line">            TempL-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>( L1-&gt;Next != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        TempL-&gt;Next = L1-&gt;Next;</span><br><span class="line">        L1-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>( L2-&gt;Next != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        TempL-&gt;Next = L2-&gt;Next;</span><br><span class="line">        L2-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编程题01——最大子列和问题"><a href="#编程题01——最大子列和问题" class="headerlink" title="编程题01——最大子列和问题"></a>编程题01——最大子列和问题</h1><p>给定<em>K</em>个整数组成的序列{ <em>N</em>1, <em>N</em>2, …, <em>N**K</em> }，“连续子列”被定义为{ <em>N**i</em>, <em>N**i</em>+1, …, <em>N**j</em> }，其中 1≤<em>i</em>≤<em>j</em>≤<em>K</em>。“最大子列和”则被定义为所有连续子列元素的和中最大者。例如给定序列{ -2, 11, -4, 13, -5, -2 }，其连续子列{ 11, -4, 13 }有最大的和20。现要求你编写程序，计算给定整数序列的最大子列和。</p><p>本题旨在测试各种不同的算法在各种数据情况下的表现。各组测试数据特点如下：</p><ul><li>数据1：与样例等价，测试基本正确性；</li><li>数据2：102个随机整数；</li><li>数据3：103个随机整数；</li><li>数据4：104个随机整数；</li><li>数据5：105个随机整数；</li></ul><h3 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入第1行给出正整数<em>K</em> (≤100000)；第2行给出<em>K</em>个整数，其间以空格分隔。</p><h3 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>在一行中输出最大子列和。如果序列中所有整数皆为负数，则输出0。</p><h3 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">6</span><br><span class="line">-2 11 -4 13 -5 -2</span><br></pre></td></tr></table></figure><h3 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">20</span><br></pre></td></tr></table></figure><h3 id="答案-2"><a href="#答案-2" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">MaxSubSeq</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    <span class="keyword">int</span> Max = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> Temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>( N &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> Input;</span><br><span class="line">        cin &gt;&gt; Input;</span><br><span class="line">        Temp += Input;</span><br><span class="line">        <span class="keyword">if</span>( Temp &gt; Max )</span><br><span class="line">        &#123;</span><br><span class="line">            Max = Temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( Temp &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            Temp = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        N--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Max;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Max = <span class="number">0</span>;</span><br><span class="line">    Max = <span class="built_in">MaxSubSeq</span>();</span><br><span class="line">    cout &lt;&lt; Max &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编程题02——Maximum-Subsequence-Sum"><a href="#编程题02——Maximum-Subsequence-Sum" class="headerlink" title="编程题02——Maximum Subsequence Sum"></a>编程题02——Maximum Subsequence Sum</h1><p>Given a sequence of <em>K</em> integers { <em>N</em>1, <em>N</em>2, …, <em>N**K</em> }. A continuous subsequence is defined to be { <em>N**i</em>, <em>N**i</em>+1, …, <em>N**j</em> } where 1≤<em>i</em>≤<em>j</em>≤<em>K</em>. The Maximum Subsequence is the continuous subsequence which has the largest sum of its elements. For example, given sequence { -2, 11, -4, 13, -5, -2 }, its maximum subsequence is { 11, -4, 13 } with the largest sum being 20.</p><p>Now you are supposed to find the largest sum, together with the first and the last numbers of the maximum subsequence.</p><h3 id="Input-Specification"><a href="#Input-Specification" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. Each case occupies two lines. The first line contains a positive integer <em>K</em> (≤10000). The second line contains <em>K</em> numbers, separated by a space.</p><h3 id="Output-Specification"><a href="#Output-Specification" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each test case, output in one line the largest sum, together with the first and the last numbers of the maximum subsequence. The numbers must be separated by one space, but there must be no extra space at the end of a line. In case that the maximum subsequence is not unique, output the one with the smallest indices <em>i</em> and <em>j</em> (as shown by the sample case). If all the <em>K</em> numbers are negative, then its maximum sum is defined to be 0, and you are supposed to output the first and the last numbers of the whole sequence.</p><h3 id="Sample-Input"><a href="#Sample-Input" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">-10 1 2 3 4 -5 -23 3 7 -21</span><br></pre></td></tr></table></figure><h3 id="Sample-Output"><a href="#Sample-Output" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10 1 4</span><br></pre></td></tr></table></figure><h3 id="答案-3"><a href="#答案-3" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">MaxSubSeq</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    <span class="keyword">int</span> TempN;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    TempN = N;</span><br><span class="line">    <span class="keyword">int</span> Max = <span class="number">0</span>; <span class="keyword">int</span> Temp = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> Start,TempStart;</span><br><span class="line">    <span class="keyword">int</span> End,TempEnd;</span><br><span class="line">    <span class="keyword">int</span> TempTrigger = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> ZeroCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> NegCnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> First,Last;</span><br><span class="line">    <span class="keyword">while</span>( TempN &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> Input;</span><br><span class="line">        cin &gt;&gt; Input;</span><br><span class="line">        <span class="keyword">if</span>( TempN == N )</span><br><span class="line">            First = Input;</span><br><span class="line">        <span class="keyword">if</span>( TempN == <span class="number">1</span> )</span><br><span class="line">            Last = Input;</span><br><span class="line">        <span class="keyword">if</span>( Input &lt; <span class="number">0</span> )</span><br><span class="line">            NegCnt++;</span><br><span class="line">        <span class="keyword">if</span>( Input == <span class="number">0</span> )</span><br><span class="line">            ZeroCnt++;</span><br><span class="line">        <span class="keyword">if</span>( TempTrigger == <span class="number">1</span> )</span><br><span class="line">            TempStart = Input;</span><br><span class="line">        TempTrigger = <span class="number">0</span>;</span><br><span class="line">        TempEnd = Input;</span><br><span class="line">        Temp += Input;</span><br><span class="line">        <span class="keyword">if</span>( Temp &gt; Max )</span><br><span class="line">        &#123;</span><br><span class="line">            Max = Temp;</span><br><span class="line">            Start = TempStart;</span><br><span class="line">            End = TempEnd;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( Temp &lt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            Temp = <span class="number">0</span>;</span><br><span class="line">            TempTrigger = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TempN--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( NegCnt == N )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0 &quot;</span> &lt;&lt; First &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; Last &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>( NegCnt + ZeroCnt == N )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0 0 0&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        cout &lt;&lt; Max &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; Start &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; End &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">MaxSubSeq</span>();</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编程题03——线性结构：一元多项式的乘法与加法运算"><a href="#编程题03——线性结构：一元多项式的乘法与加法运算" class="headerlink" title="编程题03——线性结构：一元多项式的乘法与加法运算"></a>编程题03——线性结构：一元多项式的乘法与加法运算</h1><p>设计函数分别求两个一元多项式的乘积与和。</p><h3 id="输入格式-1"><a href="#输入格式-1" class="headerlink" title="输入格式:"></a>输入格式:</h3><p>输入分2行，每行分别先给出多项式非零项的个数，再以指数递降方式输入一个多项式非零项系数和指数（绝对值均为不超过1000的整数）。数字间以空格分隔。</p><h3 id="输出格式-1"><a href="#输出格式-1" class="headerlink" title="输出格式:"></a>输出格式:</h3><p>输出分2行，分别以指数递降方式输出乘积多项式以及和多项式非零项的系数和指数。数字间以空格分隔，但结尾不能有多余空格。零多项式应输出<code>0 0</code>。</p><h3 id="输入样例-1"><a href="#输入样例-1" class="headerlink" title="输入样例:"></a>输入样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">4 3 4 -5 2  6 1  -2 0</span><br><span class="line">3 5 20  -7 4  3 1</span><br></pre></td></tr></table></figure><h3 id="输出样例-1"><a href="#输出样例-1" class="headerlink" title="输出样例:"></a>输出样例:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">15 24 -25 22 30 21 -10 20 -21 8 35 6 -33 5 14 4 -15 3 18 2 -6 1</span><br><span class="line">5 20 -4 4 -5 2 9 1 -2 0</span><br></pre></td></tr></table></figure><h3 id="答案-4"><a href="#答案-4" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElementType Coef;</span><br><span class="line">    ElementType Pow;</span><br><span class="line">    List Next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">CreateList</span><span class="params">( List L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N;</span><br><span class="line">    cin &gt;&gt; N;</span><br><span class="line">    List Tem = L;</span><br><span class="line">    <span class="keyword">if</span>( N &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>( N &gt; <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            List NewList = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">            cin &gt;&gt; NewList-&gt;Coef &gt;&gt; NewList-&gt;Pow;</span><br><span class="line">            NewList-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">            Tem-&gt;Next = NewList;</span><br><span class="line">            Tem = NewList;</span><br><span class="line">            N--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        List NewList = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">        NewList-&gt;Coef = NewList-&gt;Pow = <span class="number">0</span>;</span><br><span class="line">        NewList-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">        Tem-&gt;Next = NewList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">AddList</span><span class="params">( List L1,List L2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">    L-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    List Tem = L;</span><br><span class="line">    List TemL1 = L1-&gt;Next;</span><br><span class="line">    List TemL2 = L2-&gt;Next;</span><br><span class="line">    <span class="keyword">while</span>( TemL1!=<span class="literal">NULL</span> &amp;&amp; TemL2!=<span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( TemL1-&gt;Pow &gt; TemL2-&gt;Pow )</span><br><span class="line">        &#123;</span><br><span class="line">            List NewList = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">            NewList-&gt;Coef = TemL1-&gt;Coef;</span><br><span class="line">            NewList-&gt;Pow = TemL1-&gt;Pow;</span><br><span class="line">            NewList-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">            TemL1 = TemL1-&gt;Next;</span><br><span class="line">            Tem-&gt;Next = NewList;</span><br><span class="line">            Tem = Tem-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>( TemL1-&gt;Pow &lt; TemL2-&gt;Pow )</span><br><span class="line">        &#123;</span><br><span class="line">            List NewList = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">            NewList-&gt;Coef = TemL2-&gt;Coef;</span><br><span class="line">            NewList-&gt;Pow = TemL2-&gt;Pow;</span><br><span class="line">            NewList-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">            TemL2 = TemL2-&gt;Next;</span><br><span class="line">            Tem-&gt;Next = NewList;</span><br><span class="line">            Tem = Tem-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>( TemL1-&gt;Coef + TemL2-&gt;Coef != <span class="number">0</span> )</span><br><span class="line">            &#123;</span><br><span class="line">                List NewList = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">                NewList-&gt;Coef = TemL1-&gt;Coef + TemL2-&gt;Coef;</span><br><span class="line">                NewList-&gt;Pow = TemL1-&gt;Pow;</span><br><span class="line">                NewList-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">                TemL1 = TemL1-&gt;Next;</span><br><span class="line">                TemL2 = TemL2-&gt;Next;</span><br><span class="line">                Tem-&gt;Next = NewList;</span><br><span class="line">                Tem = Tem-&gt;Next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                TemL1 = TemL1-&gt;Next;</span><br><span class="line">                TemL2 = TemL2-&gt;Next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>( TemL1 != <span class="literal">NULL</span> &amp;&amp; (TemL1-&gt;Pow != <span class="number">0</span> || TemL1-&gt;Coef != <span class="number">0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        List NewList = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">        NewList-&gt;Coef = TemL1-&gt;Coef;</span><br><span class="line">        NewList-&gt;Pow = TemL1-&gt;Pow;</span><br><span class="line">        NewList-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">        TemL1 = TemL1-&gt;Next;</span><br><span class="line">        Tem-&gt;Next = NewList;</span><br><span class="line">        Tem = Tem-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>( TemL2 != <span class="literal">NULL</span> &amp;&amp; (TemL2-&gt;Pow != <span class="number">0</span> || TemL2-&gt;Coef != <span class="number">0</span>) )</span><br><span class="line">    &#123;</span><br><span class="line">        List NewList = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">        NewList-&gt;Coef = TemL2-&gt;Coef;</span><br><span class="line">        NewList-&gt;Pow = TemL2-&gt;Pow;</span><br><span class="line">        NewList-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">        TemL2 = TemL2-&gt;Next;</span><br><span class="line">        Tem-&gt;Next = NewList;</span><br><span class="line">        Tem = Tem-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( L-&gt;Next == <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        List NewList = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">        NewList-&gt;Coef = NewList-&gt;Pow = <span class="number">0</span>;</span><br><span class="line">        NewList-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">        L-&gt;Next = NewList;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteList</span><span class="params">( List L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List Tem = L-&gt;Next;</span><br><span class="line">    <span class="keyword">while</span>( Tem != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        L-&gt;Next = Tem-&gt;Next;</span><br><span class="line">        <span class="built_in">free</span>(Tem);</span><br><span class="line">        Tem = L-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">MultipleList</span><span class="params">( List L1,List L2 )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">    L-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    List InitialList = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">    InitialList-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    InitialList-&gt;Coef = InitialList-&gt;Pow = <span class="number">0</span>;</span><br><span class="line">    L-&gt;Next = InitialList;</span><br><span class="line">    List Tem = L;</span><br><span class="line">    List TemL1 = L1-&gt;Next;</span><br><span class="line">    List SubL = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">    SubL-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    List TemSubL = SubL;</span><br><span class="line">    <span class="keyword">while</span>( TemL1 != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        List TemL2 = L2-&gt;Next;</span><br><span class="line">        <span class="keyword">while</span>( TemL1-&gt;Coef != <span class="number">0</span> &amp;&amp; TemL2 != <span class="literal">NULL</span> &amp;&amp; TemL2-&gt;Coef != <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            List NewList = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">            NewList-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">            NewList-&gt;Pow = TemL1-&gt;Pow + TemL2-&gt;Pow;</span><br><span class="line">            NewList-&gt;Coef = TemL1-&gt;Coef * TemL2-&gt;Coef;</span><br><span class="line">            TemSubL-&gt;Next = NewList;</span><br><span class="line">            TemSubL = TemSubL-&gt;Next;</span><br><span class="line">            TemL2 = TemL2-&gt;Next;</span><br><span class="line">        &#125;</span><br><span class="line">        L = <span class="built_in">AddList</span>( Tem, SubL );</span><br><span class="line">        <span class="built_in">DeleteList</span>(Tem);</span><br><span class="line">        <span class="built_in">free</span>(Tem);</span><br><span class="line">        Tem = L;</span><br><span class="line">        <span class="built_in">DeleteList</span>(SubL);</span><br><span class="line">        TemSubL = SubL;</span><br><span class="line">        TemL1 = TemL1-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L1 = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">    L1-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    List L2 = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">    L2-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//List AddL = (List)malloc(sizeof(struct LNode));</span></span><br><span class="line">    <span class="comment">//List MulL = (List)malloc(sizeof(struct LNode));</span></span><br><span class="line">    L1 = <span class="built_in">CreateList</span>( L1 );</span><br><span class="line">    L2 = <span class="built_in">CreateList</span>( L2 );</span><br><span class="line">    List AddL = <span class="built_in">AddList</span>( L1,L2 );</span><br><span class="line">    List MulL = <span class="built_in">MultipleList</span>( L1,L2 );</span><br><span class="line">    List TemAddL = AddL-&gt;Next;</span><br><span class="line">    List TemMulL = MulL-&gt;Next;</span><br><span class="line">    cout &lt;&lt; TemMulL-&gt;Coef &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; TemMulL-&gt;Pow;</span><br><span class="line">    TemMulL = TemMulL-&gt;Next;</span><br><span class="line">    <span class="keyword">while</span>( TemMulL != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; TemMulL-&gt;Coef &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; TemMulL-&gt;Pow;</span><br><span class="line">        TemMulL = TemMulL-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; TemAddL-&gt;Coef &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; TemAddL-&gt;Pow;</span><br><span class="line">    TemAddL = TemAddL-&gt;Next;</span><br><span class="line">    <span class="keyword">while</span>( TemAddL != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; TemAddL-&gt;Coef &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; TemAddL-&gt;Pow;</span><br><span class="line">        TemAddL = TemAddL-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; endl;</span><br><span class="line">    <span class="built_in">DeleteList</span>( L1 );</span><br><span class="line">    <span class="built_in">free</span>(L1);</span><br><span class="line">    <span class="built_in">DeleteList</span>( L2 );</span><br><span class="line">    <span class="built_in">free</span>(L2);</span><br><span class="line">    <span class="built_in">DeleteList</span>( AddL );</span><br><span class="line">    <span class="built_in">free</span>(AddL);</span><br><span class="line">    <span class="built_in">DeleteList</span>( MulL );</span><br><span class="line">    <span class="built_in">free</span>(MulL);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>这一版的代码有几个<strong>心得</strong></li></ul><ol><li>使用了头结点；</li><li>构建头结点指针要做好初始化，包括头结点指向NULL指针，头结点不能赋值；</li><li>在建立链表的循环时，要注意先将框架搭好。</li></ol><h1 id="编程题04——Reversing-Linked-List"><a href="#编程题04——Reversing-Linked-List" class="headerlink" title="编程题04——Reversing Linked List"></a>编程题04——Reversing Linked List</h1><p>Given a constant <em>K</em> and a singly linked list <em>L</em>, you are supposed to reverse the links of every <em>K</em> elements on <em>L</em>. For example, given <em>L</em> being 1→2→3→4→5→6, if <em>K</em>=3, then you must output 3→2→1→6→5→4; if <em>K</em>=4, you must output 4→3→2→1→5→6.</p><h3 id="Input-Specification-1"><a href="#Input-Specification-1" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains the address of the first node, a positive <em>N</em> (≤105) which is the total number of nodes, and a positive <em>K</em> (≤<em>N</em>) which is the length of the sublist to be reversed. The address of a node is a 5-digit nonnegative integer, and NULL is represented by -1.</p><p>Then <em>N</em> lines follow, each describes a node in the format:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Address Data Next</span><br></pre></td></tr></table></figure><p>where <code>Address</code> is the position of the node, <code>Data</code> is an integer, and <code>Next</code> is the position of the next node.</p><h3 id="Output-Specification-1"><a href="#Output-Specification-1" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each case, output the resulting ordered linked list. Each node occupies a line, and is printed in the same format as in the input.</p><h3 id="Sample-Input-1"><a href="#Sample-Input-1" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">00100 6 4</span><br><span class="line">00000 4 99999</span><br><span class="line">00100 1 12309</span><br><span class="line">68237 6 -1</span><br><span class="line">33218 3 00000</span><br><span class="line">99999 5 68237</span><br><span class="line">12309 2 33218</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-1"><a href="#Sample-Output-1" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">00000 4 33218</span><br><span class="line">33218 3 12309</span><br><span class="line">12309 2 00100</span><br><span class="line">00100 1 99999</span><br><span class="line">99999 5 68237</span><br><span class="line">68237 6 -1</span><br></pre></td></tr></table></figure><h3 id="答案-5"><a href="#答案-5" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxIndex 100000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> Index;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    Index Address;</span><br><span class="line">    List Next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></span><br><span class="line">    List SList[MaxIndex];</span><br><span class="line">    <span class="keyword">int</span> Top;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">IndiceNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    Index Next;</span><br><span class="line">&#125; Indice[MaxIndex];</span><br><span class="line"></span><br><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack S = (Stack)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct SNode));</span><br><span class="line">    S-&gt;Top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">( Stack S, List L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S-&gt;SList[++S-&gt;Top] = L;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">Pop</span><span class="params">( Stack S )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;SList[S-&gt;Top--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintAddress</span><span class="params">( Index Address )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> cnt = <span class="number">5</span>;</span><br><span class="line">    <span class="keyword">int</span> WeiShu = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( Address/WeiShu != <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        WeiShu *= <span class="number">10</span>;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( Address == <span class="number">0</span> )</span><br><span class="line">        cnt--;</span><br><span class="line">    <span class="keyword">while</span>( cnt &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;0&quot;</span>;</span><br><span class="line">        cnt--;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; Address;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">( List L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( L-&gt;Next != <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">PrintAddress</span>( L-&gt;Address );</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; L-&gt;Data &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">        <span class="built_in">PrintAddress</span>( L-&gt;Next-&gt;Address );</span><br><span class="line">        cout &lt;&lt; endl;</span><br><span class="line">        L = L-&gt;Next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">PrintAddress</span>( L-&gt;Address );</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; L-&gt;Data &lt;&lt; <span class="string">&quot; -1&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteList</span><span class="params">( List L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span>( L!=<span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        List Tmp = L;</span><br><span class="line">        L = L-&gt;Next;</span><br><span class="line">        <span class="built_in">free</span>(Tmp);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Index Start;</span><br><span class="line">    <span class="keyword">int</span> N,SubN;</span><br><span class="line">    cin &gt;&gt; Start &gt;&gt; N &gt;&gt; SubN;</span><br><span class="line">    <span class="keyword">int</span> i = N;</span><br><span class="line">    <span class="keyword">while</span>( i &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        Index Order;</span><br><span class="line">        cin &gt;&gt; Order;</span><br><span class="line">        cin &gt;&gt; Indice[Order].Data &gt;&gt; Indice[Order].Next;</span><br><span class="line">        i--;</span><br><span class="line">    &#125;</span><br><span class="line">    List L = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">    L-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;Address = Start;</span><br><span class="line">    L-&gt;Data = Indice[Start].Data;</span><br><span class="line">    List TemList = L;</span><br><span class="line">    List StartList = <span class="literal">NULL</span>;</span><br><span class="line">    N = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>( Indice[Start].Next != <span class="number">-1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        Start = Indice[Start].Next;</span><br><span class="line">        List NewList = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">        NewList-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">        NewList-&gt;Address = Start;</span><br><span class="line">        NewList-&gt;Data = Indice[Start].Data;</span><br><span class="line">        TemList-&gt;Next = NewList;</span><br><span class="line">        TemList = TemList-&gt;Next;</span><br><span class="line">        N++;</span><br><span class="line">    &#125;</span><br><span class="line">    TemList = L;</span><br><span class="line">    Stack S = <span class="built_in">CreateStack</span>();</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( i % SubN == <span class="number">0</span> )</span><br><span class="line">        &#123;</span><br><span class="line">            S-&gt;Top = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SubN;i++ )</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">Push</span>( S,TemList );</span><br><span class="line">                TemList = TemList-&gt;Next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;SubN;i++ )</span><br><span class="line">            &#123;</span><br><span class="line">                List NewList = <span class="built_in">Pop</span>( S );</span><br><span class="line">                <span class="keyword">if</span>( StartList == <span class="literal">NULL</span> )</span><br><span class="line">                &#123;</span><br><span class="line">                    L = NewList;</span><br><span class="line">                    StartList = NewList;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    StartList-&gt;Next = NewList;</span><br><span class="line">                    StartList = StartList-&gt;Next;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            StartList-&gt;Next = TemList;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    TemList = L;</span><br><span class="line">    <span class="built_in">PrintList</span>( TemList );</span><br><span class="line">    <span class="built_in">DeleteList</span>( TemList );</span><br><span class="line">    <span class="built_in">free</span>(S);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="编程题05——线性结构4：Pop-Sequence"><a href="#编程题05——线性结构4：Pop-Sequence" class="headerlink" title="编程题05——线性结构4：Pop Sequence"></a>编程题05——线性结构4：Pop Sequence</h1><p>Given a stack which can keep <em>M</em> numbers at most. Push <em>N</em> numbers in the order of 1, 2, 3, …, <em>N</em> and pop randomly. You are supposed to tell if a given sequence of numbers is a possible pop sequence of the stack. For example, if <em>M</em> is 5 and <em>N</em> is 7, we can obtain 1, 2, 3, 4, 5, 6, 7 from the stack, but not 3, 2, 1, 7, 5, 6, 4.</p><h3 id="Input-Specification-2"><a href="#Input-Specification-2" class="headerlink" title="Input Specification:"></a>Input Specification:</h3><p>Each input file contains one test case. For each case, the first line contains 3 numbers (all no more than 1000): <em>M</em> (the maximum capacity of the stack), <em>N</em> (the length of push sequence), and <em>K</em> (the number of pop sequences to be checked). Then <em>K</em> lines follow, each contains a pop sequence of <em>N</em> numbers. All the numbers in a line are separated by a space.</p><h3 id="Output-Specification-2"><a href="#Output-Specification-2" class="headerlink" title="Output Specification:"></a>Output Specification:</h3><p>For each pop sequence, print in one line “YES” if it is indeed a possible pop sequence of the stack, or “NO” if not.</p><h3 id="Sample-Input-2"><a href="#Sample-Input-2" class="headerlink" title="Sample Input:"></a>Sample Input:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">5 7 5</span><br><span class="line">1 2 3 4 5 6 7</span><br><span class="line">3 2 1 7 5 6 4</span><br><span class="line">7 6 5 4 3 2 1</span><br><span class="line">5 6 4 3 7 2 1</span><br><span class="line">1 7 6 5 4 3 2</span><br></pre></td></tr></table></figure><h3 id="Sample-Output-2"><a href="#Sample-Output-2" class="headerlink" title="Sample Output:"></a>Sample Output:</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">YES</span><br><span class="line">NO</span><br><span class="line">NO</span><br><span class="line">YES</span><br><span class="line">NO</span><br></pre></td></tr></table></figure><h3 id="答案-6"><a href="#答案-6" class="headerlink" title="答案"></a>答案</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize 1000</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span>&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> Capacity;</span><br><span class="line">    <span class="keyword">int</span> Top;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack <span class="title">CreateStack</span><span class="params">( <span class="keyword">int</span> M )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack S = (Stack)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct SNode));</span><br><span class="line">    S-&gt;Capacity = M;</span><br><span class="line">    S-&gt;Top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">( Stack S )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( S-&gt;Top == <span class="number">-1</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">( Stack S )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( S-&gt;Top == S-&gt;Capacity<span class="number">-1</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Push</span><span class="params">( Stack S,ElementType Item )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S-&gt;Data[++S-&gt;Top] = Item;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">ElementType <span class="title">Pop</span><span class="params">( Stack S )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;Data[S-&gt;Top--];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">RightIndice</span><span class="params">( ElementType Number[],Stack S,<span class="keyword">int</span> N )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> Index = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">Push</span>(S,<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">1</span>;i&lt;N;i++ )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( S-&gt;Data[S-&gt;Top] == Number[Index] )</span><br><span class="line">        &#123;</span><br><span class="line">            ElementType Item = <span class="built_in">Pop</span>(S);</span><br><span class="line">            Index++;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">            <span class="keyword">if</span>( <span class="built_in">IsFull</span>(S) )</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="built_in">Push</span>(S,i+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>( !<span class="built_in">IsEmpty</span>(S) )</span><br><span class="line">    &#123;</span><br><span class="line">        ElementType Item = <span class="built_in">Pop</span>(S);</span><br><span class="line">        <span class="keyword">if</span>( Item != Number[Index++] )</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitialStack</span><span class="params">( Stack S )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S-&gt;Top = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> M,N,K;</span><br><span class="line">    cin &gt;&gt; M &gt;&gt; N &gt;&gt; K;</span><br><span class="line">    Stack S = <span class="built_in">CreateStack</span>( M );</span><br><span class="line">    ElementType Number[N];</span><br><span class="line">    <span class="keyword">while</span>( K &gt; <span class="number">0</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>( <span class="keyword">int</span> i=<span class="number">0</span>;i&lt;N;i++ )</span><br><span class="line">            cin &gt;&gt; Number[i];</span><br><span class="line">        <span class="keyword">if</span>( <span class="built_in">RightIndice</span>( Number,S,N ) )</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;YES&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;NO&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="built_in">InitialStack</span>( S );</span><br><span class="line">        K--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>基础数据结构与算法（一）</title>
      <link href="/2021/06/11/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2021/06/11/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<p>本文章主要介绍线性结构的基本操作，代码来自浙大慕课。</p><span id="more"></span><h1 id="第一部分-线性结构"><a href="#第一部分-线性结构" class="headerlink" title="第一部分 线性结构"></a>第一部分 线性结构</h1><p><strong>线性结构主要包括线性表、堆栈和队列，基本操作有建立初始结构，插入、删除、判断是否为空或满的，不止线性结构如此，一般数据结构均是以上几种基本操作。</strong></p><h2 id="线性结构"><a href="#线性结构" class="headerlink" title="线性结构"></a>线性结构</h2><p>线性结构分为顺序存储和链表两种模式。</p><h3 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h3><p>顺序存储即开辟一块固定空间，大小固定，所有操作均在这块空间上进行。</p><ul><li>开辟初始空间</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxSize Max</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> Cnt;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">InitialList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List L = (List)<span class="built_in">malloc</span>( <span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode) );</span><br><span class="line">    L-&gt;Cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断是否为空/为满</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">( List L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( L-&gt;Cnt == MaxSize )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">( List L )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( L-&gt;Cnt == <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">( List L, ElementType E )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">IsFull</span>( L ) )</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Full&quot;</span> &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        L-&gt;Data[L-&gt;Cnt++] = E;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul><li>链表初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">List</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    List Next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">List <span class="title">InitialList</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//- 创建头结点的方法</span></span><br><span class="line">    List L = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">    L-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">( List L,ElementType Item )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    List Temp = (List)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct LNode));</span><br><span class="line">    Temp-&gt;Data = Item;</span><br><span class="line">    Temp-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    L-&gt;Next = Temp;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="堆栈"><a href="#堆栈" class="headerlink" title="堆栈"></a>堆栈</h2><p>堆栈指满足先进后出原则的一个线性存储结构。</p><h3 id="顺序存储的堆栈"><a href="#顺序存储的堆栈" class="headerlink" title="顺序存储的堆栈"></a>顺序存储的堆栈</h3><ul><li>初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> Top;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack <span class="title">InitialStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack S = (Stack)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct SNode));</span><br><span class="line">    S-&gt;Top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断堆栈是否为满/为空</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">( Stack S )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( S-&gt;Top &lt; <span class="number">0</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">( Stack S )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( S-&gt;Top == MaxSize<span class="number">-1</span> )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">( Stack S,ElementType Item )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">IsFull</span>( S ) )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Full&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        S-&gt;Data[++S-&gt;Top] = Item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">Delete</span><span class="params">( Stack S )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">IsEmpty</span>( S ) )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> S-&gt;Data[S-&gt;Top--];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="堆栈的链表存储结构（头结点结构）"><a href="#堆栈的链表存储结构（头结点结构）" class="headerlink" title="堆栈的链表存储结构（头结点结构）"></a>堆栈的链表存储结构（头结点结构）</h3><ul><li>初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SNode</span> *<span class="title">Stack</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">SNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    Stack Next;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">Stack <span class="title">InitialStack</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack S = (Stack)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>( struct SNode ));</span><br><span class="line">    S-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> S;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">( Stack S, ElementType Item )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Stack ItemP = (Stack)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct SNode));</span><br><span class="line">    ItemP-&gt;Data = Item;</span><br><span class="line">    ItemP-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    Stack Tmp;</span><br><span class="line">    Tmp = S-&gt;Next;</span><br><span class="line">    S-&gt;Next = ItemP;</span><br><span class="line">    ItemP-&gt;Next = Tmp;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">Delete</span><span class="params">( Stack S )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( S-&gt;Next == <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    Stack Tmp = S-&gt;Next;</span><br><span class="line">    S-&gt;Next = Tmp-&gt;Next;</span><br><span class="line">    ElementType Item = Tmp-&gt;Data;</span><br><span class="line">    <span class="built_in">free</span>( Tmp );</span><br><span class="line">    <span class="keyword">return</span> Item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><h3 id="顺序存储队列"><a href="#顺序存储队列" class="headerlink" title="顺序存储队列"></a>顺序存储队列</h3><ul><li>初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElementType Data[MaxSize];</span><br><span class="line">    <span class="keyword">int</span> Front;</span><br><span class="line">    <span class="keyword">int</span> Rear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//- 采用循环队列的方法，</span></span><br><span class="line"><span class="function">Queue <span class="title">InitialQueue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue Q = (Queue)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct QNode));</span><br><span class="line">    Q-&gt;Front = Q-&gt;Rear = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>判断为空/为满</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsFull</span><span class="params">( Queue Q )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( Q-&gt;Front == Q-&gt;Rear )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">( Queue Q )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( (Q-&gt;Rear+<span class="number">1</span>)%MaxSize==Q-&gt;Front )</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">( Queue Q, ElementType Item )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">IsFull</span>( Q ) )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Full&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Q-&gt;Rear = ( Q-&gt;Rear + <span class="number">1</span> )%MaxSize;</span><br><span class="line">        Q-&gt;Data[Q-&gt;Rear] = Item;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Queue <span class="title">Delete</span><span class="params">( Queue Q )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ElementType Item;</span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">IsEmpty</span>( Q ) )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Q-&gt;Front = ( Q-&gt;Front + <span class="number">1</span> )%MaxSize;</span><br><span class="line">        Item = Q-&gt;Data[Q-&gt;Front];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链表存储队列"><a href="#链表存储队列" class="headerlink" title="链表存储队列"></a>链表存储队列</h3><ul><li>初始化</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">Queue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">QNode</span>&#123;</span></span><br><span class="line">    ElementType Data;</span><br><span class="line">    Queue Next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HeadQNode</span> *<span class="title">HeadQueue</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HeadQNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    Queue Front;</span><br><span class="line">    Queue Rear;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">HeadQueue <span class="title">Initial</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    HeadQueue HQ = (HeadQueue)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct HeadQNode));</span><br><span class="line">    HQ-&gt;Front = HQ-&gt;Rear = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> HQ;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>插入</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Insert</span><span class="params">( HeadQueue HQ, ElementType Item )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Queue Q = (Queue)<span class="built_in">malloc</span>(<span class="built_in"><span class="keyword">sizeof</span></span>(struct QNode));</span><br><span class="line">    Q-&gt;Data = Item;</span><br><span class="line">    Q-&gt;Next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>( HQ-&gt;Front == <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        HQ-&gt;Front = Q;</span><br><span class="line">        HQ-&gt;Rear = Q;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        Queue RearQ = HQ-&gt;Rear;</span><br><span class="line">        RearQ-&gt;Next = Q;</span><br><span class="line">        HQ-&gt;Rear = Q;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>删除</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ElementType <span class="title">Delete</span><span class="params">( HeadQueue HQ )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>( HQ-&gt;Front == <span class="literal">NULL</span> )</span><br><span class="line">    &#123;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;Empty&quot;</span> &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">return</span> ERROR;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>( HQ-&gt;Front == HQ-&gt;Rear )</span><br><span class="line">    &#123;</span><br><span class="line">        ElementType Item = HQ-&gt;Front-&gt;Data;</span><br><span class="line">        <span class="built_in">free</span>( HQ-&gt;Front );</span><br><span class="line">        HQ-&gt;Front = HQ-&gt;Rear = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">return</span> Item;</span><br><span class="line">    &#125;</span><br><span class="line">    Queue Q = HQ-&gt;Front;</span><br><span class="line">    HQ-&gt;Front = Q-&gt;Next;</span><br><span class="line">    ElementType Item = Q-&gt;Data;</span><br><span class="line">    <span class="built_in">free</span>(Q);</span><br><span class="line">    <span class="keyword">return</span> Item;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构与算法 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>MarkDown使用手册</title>
      <link href="/2021/06/06/MarkDown%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/"/>
      <url>/2021/06/06/MarkDown%E4%BD%BF%E7%94%A8%E6%89%8B%E5%86%8C/</url>
      
        <content type="html"><![CDATA[<p>为MarkDown的使用提供一份说明文档，部分结果仅展示成果，可以复制到本地的<a href="https://www.typora.io/">Typora</a>查看源码。未来会持续更新</p><span id="more"></span><h3 id="一、标题"><a href="#一、标题" class="headerlink" title="一、标题"></a>一、标题</h3><p>标题一共包括六个级别，用#来表示，示意如下：<br># 标题1<br>## 标题2<br>### 标题3<br>#### 标题4<br>##### 标题5<br>###### 标题6<br>在MarkDown下分别表示如下：</p><h1 id="标题1"><a href="#标题1" class="headerlink" title="标题1"></a>标题1</h1><h2 id="标题2"><a href="#标题2" class="headerlink" title="标题2"></a>标题2</h2><h3 id="标题3"><a href="#标题3" class="headerlink" title="标题3"></a>标题3</h3><h4 id="标题4"><a href="#标题4" class="headerlink" title="标题4"></a>标题4</h4><h5 id="标题5"><a href="#标题5" class="headerlink" title="标题5"></a>标题5</h5><h6 id="标题6"><a href="#标题6" class="headerlink" title="标题6"></a>标题6</h6><p><strong>注：# 和字符中间空一格</strong></p><h3 id="二、列表"><a href="#二、列表" class="headerlink" title="二、列表"></a>二、列表</h3><p>列表的使用时-空一格加字符，如下：<br>- 文本1<br>- 文本2<br>- 文本3</p><ul><li>文本1</li><li>文本2</li><li>文本3</li></ul><p>如果加上有序序号的话</p><ol><li>文本1</li><li>文本2</li><li>文本3</li></ol><h3 id="三、插入链接和图片"><a href="#三、插入链接和图片" class="headerlink" title="三、插入链接和图片"></a>三、插入链接和图片</h3><h4 id="1-插入链接"><a href="#1-插入链接" class="headerlink" title="1.插入链接"></a>1.插入链接</h4><p>插入链接使用[显示文本]+(网址)的方式来显示链接，具体如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[百度](https://www.baidu.com/)</span><br></pre></td></tr></table></figure><p><a href="https://www.baidu.com/">百度</a></p><h4 id="2-插入图片"><a href="#2-插入图片" class="headerlink" title="2.插入图片"></a>2.插入图片</h4><p>出入图片和插入链接相似，使用</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">![](https://gitee.com/nighost/case/raw/master/Case.png)</span><br></pre></td></tr></table></figure><p><img src="https://gitee.com/nighost/case/raw/master/Case.png" alt=""></p><p><strong>注：印象笔记的网址解析有问题，所以这里没有显示，但大体是这样用</strong></p><h3 id="四、引用"><a href="#四、引用" class="headerlink" title="四、引用"></a>四、引用</h3><p>引用只要使用> 文字即可</p><blockquote><p>人生得意须尽欢，莫使金樽空对月</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt; 人生得意须尽欢，莫使金樽空对月</span><br></pre></td></tr></table></figure><h3 id="五、粗体和斜体"><a href="#五、粗体和斜体" class="headerlink" title="五、粗体和斜体"></a>五、粗体和斜体</h3><p>斜体使用两个*，粗体使用四个*<br><em>斜体</em><br><strong>粗体</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">*斜体*</span><br><span class="line">**粗体**</span><br></pre></td></tr></table></figure><h3 id="六、代码引用"><a href="#六、代码引用" class="headerlink" title="六、代码引用"></a>六、代码引用</h3><h4 id="1-单行代码"><a href="#1-单行代码" class="headerlink" title="1.单行代码"></a>1.单行代码</h4><p><code>hello world</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">`hello world`</span><br></pre></td></tr></table></figure><h4 id="2-代码块"><a href="#2-代码块" class="headerlink" title="2.代码块"></a>2.代码块</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;isotream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;hello world&quot;</span> &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="七、表格"><a href="#七、表格" class="headerlink" title="七、表格"></a>七、表格</h3><div class="table-container"><table><thead><tr><th>辛烷值</th><th>正庚烷比例</th><th>异辛烷比例</th><th>甲苯比例</th></tr></thead><tbody><tr><td>100</td><td>0</td><td>100</td><td>0</td></tr><tr><td>70</td><td>30</td><td>70</td><td>0</td></tr></tbody></table></div><h3 id="八、数学公式"><a href="#八、数学公式" class="headerlink" title="八、数学公式"></a>八、数学公式</h3><h4 id="1-行内公式和读行公式"><a href="#1-行内公式和读行公式" class="headerlink" title="1.行内公式和读行公式"></a>1.行内公式和读行公式</h4><ul><li>行内公式<br>一些内容$1+1=2$</li><li>独行公式<script type="math/tex; mode=display">1+1=2</script></li></ul><h4 id="2-上标、下标与组合"><a href="#2-上标、下标与组合" class="headerlink" title="2.上标、下标与组合"></a>2.上标、下标与组合</h4><ul><li><p>上标</p><script type="math/tex; mode=display">2^2=4</script></li><li><p>下标</p><script type="math/tex; mode=display">U_k=5</script></li><li><p>组合<br>使用{}来包含，避免歧义</p><script type="math/tex; mode=display">{16}_{8}O{2+}_{2}</script></li></ul><h4 id="3-汉字、字体与格式"><a href="#3-汉字、字体与格式" class="headerlink" title="3.汉字、字体与格式"></a>3.汉字、字体与格式</h4><ul><li>汉字<br>汉字的输入格式如下：<br>\$$V_{\mbox{初始}}$$<br><strong>注：印象笔记不支持数学公式中的汉字输入</strong></li><li>字体控制<br>不知道怎么做的控制，但加入displaystyle后字体明显变好看，如下：<br>$\displaystyle \frac{x+y}{y+z}$<br>$\frac{x+y}{y+z}$<br>再比如加和符号：<br>$\displaystyle \sum_X$<br>$\sum_X$<br>可以看到，加入字体控制，X的布局更合理</li><li>下划线控制<br>${x+y}$<br>$\underline {x+y}$</li><li>标签<br>$\tag{11}$<br><strong>注：印象笔记也不支持这个功能</strong></li><li>上大括号<br>$\overbrace{a+b+c+d}$</li><li>下大括号<br>$\underbrace {a+b+c+d}$</li><li><p>上位符号<br>写法如下<br>$stakcrel{上位符号}{基位符号}$<br>$\vec{x}\stackrel{\mathrm{def}}{=}{x_1,\dots,x_n}$<br>$\stackrel{\mathrm{de}}{=}$</p></li><li><p>公式字符加粗</p></li><li>$\boldsymbol{S}$</li></ul><h4 id="4-占位符"><a href="#4-占位符" class="headerlink" title="4.占位符"></a>4.占位符</h4><ul><li>两个quad空格<br>$x\qquad y$</li><li>一个quad空格<br>$x\quad y$</li><li>大空格(\加一个空格)<br>$x\ y$</li><li>中空格<br>$x\:y$</li><li>小空格<br>$x\,y$</li><li>没有空格<br>$xy$</li><li>紧贴<br>$x!y$</li></ul><h4 id="5-定位符与组合"><a href="#5-定位符与组合" class="headerlink" title="5.定位符与组合"></a>5.定位符与组合</h4><ul><li>括号<br>$(xy)$</li><li>中括号<br>$[xy]$</li><li>大括号<br>$\{xy\}$</li></ul><h4 id="6-四则运算"><a href="#6-四则运算" class="headerlink" title="6.四则运算"></a>6.四则运算</h4><ul><li>加法<br>$x+y=z$</li><li>减法<br>$x-y=z$</li><li>加减法<br>$x \pm y = z$</li><li>减加法<br>$x \mp y = z$</li><li>乘法<br>$x \times y = z$</li><li>点乘<br>$x \cdot y = z$</li><li>星乘<br>$x \ast y = z$</li><li>除法<br>$x \div y = z$</li><li>斜法<br>$x / y = z$</li><li>分式表示<br>$\displaystyle \frac{x}{y}$</li><li>分式表示<br>${x} \voer {y}$<br><strong>注：印象笔记不支持该显示</strong></li><li>绝对值<br>$|x|=|y|$</li></ul><h4 id="7-高级运算"><a href="#7-高级运算" class="headerlink" title="7.高级运算"></a>7.高级运算</h4><ul><li>平均数计算<br>$\displaystyle \overline{xyz}$</li><li>开二次方<br>$\sqrt x$</li><li>开方运算<br>$\sqrt[3]{xy}$</li><li>对数运算<br>$\log(x)$</li><li>极限运算<br>$\lim^{x\to\infty}_{y\to0}{\frac{x}{y}}$</li><li>字符控制极限运算<br>$\displaystyle \lim^{x\to\infty}_{y\to0}{\frac{x}{y}}$</li><li>求和运算<br>$\sum^{x\to\infty}_{y\to0}{\frac{x}{y}}$</li><li>字符控制求和运算<br>$\displaystyle \sum^{x\to\infty}_{y\to0}{\frac{x}{y}}$</li><li>积分运算<br>$\int^{\infty}_{0}xdx$</li><li>字符控制积分运算<br>$\displaystyle \int^{\infty}_{0}xdx$</li><li>微分运算<br>$\frac{\partial x}{\partial y}$</li><li>字符控制微分运算<br>$\displaystyle \frac{\partial x}{\partial y}$</li><li>矩阵表示<br>中括号表示</li></ul><script type="math/tex; mode=display">\left[\begin{matrix}   1 & 2 & 3\\   4 & 5 & 6\\   7 & 8 & 9\end{matrix}\right]</script><p>大括号表示</p><script type="math/tex; mode=display">\left\{\begin{matrix}   1 & 2 & 3\\   4 & 5 & 6\\   7 & 8 & 9'\end{matrix}\right\}</script><h5 id="8-逻辑运算"><a href="#8-逻辑运算" class="headerlink" title="8.逻辑运算"></a>8.逻辑运算</h5><ul><li>等于<br>$x+y=z$</li><li>大于<br>$x+y&gt;z$</li><li>小于<br>$x+y&lt;z$</li><li>大于等于<br>$x+y \geq z$</li><li>小于等于<br>$x+y \leq z$</li><li>不等于<br>$x+y \neq z$</li><li>不大于等于<br>$x+y \ngeq z$</li><li>不大于等于<br>$x+y \not\geq z$</li><li>不小于等于<br>$x+y \nleq z$</li><li>不小于等于<br>$x+y \not\leq z$</li><li>约等于<br>$x+y \approx z$</li><li>恒定等于<br>$x+y \equiv z$</li></ul><h5 id="9-集合运算"><a href="#9-集合运算" class="headerlink" title="9.集合运算"></a>9.集合运算</h5><ul><li>属于<br>$x \in y$</li><li>不属于<br>$x \notin y$</li><li>不属于<br>$x \not\in y$</li><li>子集<br>$x \subset y$<br>$x \supset y$</li><li>真子集<br>$x \subseteq y$<br>$x \supseteq y$</li><li>非真子集<br>$x \subsetneq y$<br>$x \supsetneq y$</li><li>非子集<br>$x \not\subset y$<br>$x \not\supset y$</li><li>并集<br>$x \cup y$</li><li>交集<br>$x \cap y$</li><li>差集<br>$x \setminus y$</li><li>同或<br>$x \bigodot y$</li><li>同与<br>$x \bigotimes y$</li><li>实数<br>$\mathbb{R}$</li><li>自然数<br>$\mathbb{Z}$</li><li>空集<br>$\emptyset$</li></ul><h5 id="10-数学符号"><a href="#10-数学符号" class="headerlink" title="10.数学符号"></a>10.数学符号</h5><ul><li><p>无穷<br>$\infty$</p></li><li><p>虚数<br>$\imath$<br>$\jmath$</p></li><li><p>数学符号<br>$\displaystyle \hat{a}$<br>$\check{a}$<br>$\breve{a}$<br>$\tilde{a}$<br>$\bar{a}$<br>$\acute{a}$<br>$\grave{a}$<br>$\mathring{a}$</p></li><li><p>矢量符号<br>$\displaystyle \vec{a}$</p></li><li><p>一阶导数符号<br>$\dot{a}$</p></li><li><p>二阶导数符号<br>$\ddot{a}$</p></li><li><p>上箭头<br>$\uparrow$<br>$\Uparrow$</p></li><li><p>下箭头<br>$\downarrow$<br>$\Downarrow$</p></li><li><p>左箭头<br>$\leftarrow$<br>$\Leftarrow$</p></li><li><p>右箭头<br>$\rightarrow$<br>$\Rightarrow$</p></li><li><p>低端对齐省略号<br>$1,2,\ldots,n$</p></li><li><p>中线对齐省略号<br>$\displaystyle X_1^2+X_2^2+X_3^2+\cdots+X_N^2$</p></li><li><p>竖直对齐省略号(矩阵使用)<br>$\vdots$</p></li><li><p>斜对齐省略号<br>$\ddots$</p></li><li><p>散度/梯度符号<br>$\nabla$</p></li><li><p>向下取整</p><p>$\lfloor$</p><p>$\rfloor$</p></li><li><p>向上取整</p><p>$\lceil$</p><p>$\rceil$</p></li></ul><h5 id="11-希腊字母"><a href="#11-希腊字母" class="headerlink" title="11.希腊字母"></a>11.希腊字母</h5><div class="table-container"><table><thead><tr><th>字母</th><th>实现</th><th>字母</th><th>实现</th></tr></thead><tbody><tr><td>A</td><td>A</td><td>$\alpha$</td><td>\alpha</td></tr><tr><td>B</td><td>B</td><td>$\beta$</td><td>\beta</td></tr><tr><td>$\Gamma$</td><td>\Gamma</td><td>$\gamma$</td><td>\gamma</td></tr><tr><td>$\Delta$</td><td>\Delta</td><td>$\delta$</td><td>\delta</td></tr><tr><td>E</td><td>E</td><td>$\epsilon$</td><td>\epsilon</td></tr><tr><td>Z</td><td>Z</td><td>$\zeta$</td><td>\zeta</td></tr><tr><td>H</td><td>H</td><td>$\eta$</td><td>\eta</td></tr><tr><td>$\Theta$</td><td>\Theta</td><td>$\theta$</td><td>\theta</td></tr><tr><td>I</td><td>I</td><td>$\iota$</td><td>\iota</td></tr><tr><td>K</td><td>K</td><td>$\kappa$</td><td>\kappa</td></tr><tr><td>$\Lambda$</td><td>\Lambda</td><td>$\lambda$</td><td>\lambda</td></tr><tr><td>M</td><td>M</td><td>$\mu$</td><td>\mu</td></tr><tr><td>N</td><td>N</td><td>$\nu$</td><td>\nu</td></tr><tr><td>$\Xi$</td><td>\Xi</td><td>$\xi$</td><td>\xi</td></tr><tr><td>O</td><td>$O$</td><td>$\omicron$</td><td>\omicron</td></tr><tr><td>$\Pi$</td><td>\Pi</td><td>$\pi$</td><td>\pi</td></tr><tr><td>$P$</td><td>P</td><td>$\rho$</td><td>\rho</td></tr><tr><td>$\Sigma$</td><td>\Sigma</td><td>$\sigma$</td><td>\sigma</td></tr><tr><td>T</td><td>T</td><td>$\tau$</td><td>\tau</td></tr><tr><td>$\Upsilon$</td><td>\Upsilon</td><td>$\upsilon$</td><td>\upsilon</td></tr><tr><td>$\Phi$</td><td>\Phi</td><td>$\phi$</td><td>\phi</td></tr><tr><td>$X$</td><td>X</td><td>$\chi$</td><td>\chi</td></tr><tr><td>$\Psi$</td><td>\Psi</td><td>$\psi$</td><td>\psi</td></tr><tr><td>$\Omega$</td><td>\Omega</td><td>$\omega$</td><td>\omega</td></tr></tbody></table></div><h5 id="12-多行数学公式"><a href="#12-多行数学公式" class="headerlink" title="12.多行数学公式"></a>12.多行数学公式</h5><script type="math/tex; mode=display">\begin{aligned}x &= v_0\cos\theta t \\y &= v_0\sin\theta t - \frac{1}{2}gt^2 \\y &= v_0\sin\theta t - \frac{1}{2}gt^2\end{aligned}</script><h3 id="九、流程图"><a href="#九、流程图" class="headerlink" title="九、流程图"></a>九、流程图</h3><p><strong>注：在印象笔记中流程图使用代码块功能，但在其他markdown中不用使用代码块</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[模块A] --&gt;|A1| B(模块B)</span><br><span class="line">B --&gt; C&#123;判断条件C&#125;</span><br><span class="line">C --&gt;|条件C1| D[模块D]</span><br><span class="line">C --&gt;|条件C2| E[模块E]</span><br><span class="line">C --&gt;|条件C3| F[模块F]</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 工具 </category>
          
      </categories>
      
      
    </entry>
    
    
  
  
</search>
